"use strict";const utils=require("@typescript-eslint/utils"),n$3=require("typescript"),node_path=require("node:path"),node_module=require("node:module"),scopeManager=require("@typescript-eslint/scope-manager");var _documentCurrentScript=typeof document<"u"?document.currentScript:null;function _interopDefaultCompat(b){return b&&typeof b=="object"&&"default"in b?b.default:b}const n__default=_interopDefaultCompat(n$3),version="1.3.12",createEslintRule=utils.ESLintUtils.RuleCreator(b=>`https://github.com/vitest-dev/eslint-plugin-vitest/blob/main/docs/rules/${b}.md`),joinNames=(b,Y)=>b&&Y?`${b}.${Y}`:null,isFunction=b=>b.type===utils.AST_NODE_TYPES.FunctionExpression||b.type===utils.AST_NODE_TYPES.ArrowFunctionExpression;function getNodeName(b){if(isSupportedAccessor(b))return getAccessorValue(b);switch(b.type){case utils.AST_NODE_TYPES.TaggedTemplateExpression:return getNodeName(b.tag);case utils.AST_NODE_TYPES.MemberExpression:return joinNames(getNodeName(b.object),getNodeName(b.property));case utils.AST_NODE_TYPES.NewExpression:case utils.AST_NODE_TYPES.CallExpression:return getNodeName(b.callee)}return null}const isSupportedAccessor=(b,Y)=>isIdentifier(b,Y)||isStringNode(b,Y),isIdentifier=(b,Y)=>b.type===utils.AST_NODE_TYPES.Identifier&&(Y===void 0||b.name===Y),S$5=(b,Y)=>b.type===utils.AST_NODE_TYPES.TemplateLiteral&&b.quasis.length===1&&(Y===void 0||b.quasis[0].value.raw===Y),g$3=(b,Y)=>b.type===utils.AST_NODE_TYPES.Literal&&typeof b.value=="string"&&(Y===void 0||b.value===Y),isStringNode=(b,Y)=>g$3(b,Y)||S$5(b,Y),getAccessorValue=b=>b.type===utils.AST_NODE_TYPES.Identifier?b.name:getStringValue(b),getStringValue=b=>b?.type===utils.AST_NODE_TYPES.TemplateLiteral?b.quasis[0].value.raw:b?.value,replaceAccessorFixer=(b,Y,q)=>b.replaceText(Y,Y.type===utils.AST_NODE_TYPES.Identifier?q:`'${q}'`),removeExtraArgumentsFixer=(b,Y,q,$)=>{const B=q.arguments[$],F=q.arguments[q.arguments.length-1],{sourceCode:W}=Y;let V=W.getTokenAfter(F);return V.value===","&&(V=W.getTokenAfter(V)),b.removeRange([B.range[0],V.range[0]])},isParsedInstanceOfMatcherCall=(b,Y)=>getAccessorValue(b.matcher)==="toBeInstanceOf"&&b.args.length===1&&isSupportedAccessor(b.args[0],Y);var UtilName=(b=>(b.vi="vi",b.vitest="vitest",b))(UtilName||{}),DescribeAlias=(b=>(b.describe="describe",b.fdescribe="fdescribe",b.xdescribe="xdescribe",b))(DescribeAlias||{}),TestCaseName=(b=>(b.fit="fit",b.it="it",b.test="test",b.xit="xit",b.xtest="xtest",b.bench="bench",b))(TestCaseName||{}),HookName=(b=>(b.beforeAll="beforeAll",b.beforeEach="beforeEach",b.afterAll="afterAll",b.afterEach="afterEach",b))(HookName||{}),ModifierName=(b=>(b.to="to",b.have="have",b.not="not",b.rejects="rejects",b.resolves="resolves",b.returns="returns",b.branded="branded",b.asserts="asserts",b.constructorParameters="constructorParameters",b.parameters="parameters",b.thisParameter="thisParameter",b.guards="guards",b.instance="instance",b.items="items",b))(ModifierName||{}),EqualityMatcher=(b=>(b.toBe="toBe",b.toEqual="toEqual",b.toStrictEqual="toStrictEqual",b))(EqualityMatcher||{});function isClassOrFunctionType(b){return b.getCallSignatures().length>0?!0:b.getSymbol()?.getDeclarations()?.some(Y=>n__default.isArrowFunction(Y)||n__default.isClassDeclaration(Y)||n__default.isClassExpression(Y)||n__default.isFunctionDeclaration(Y)||n__default.isFunctionExpression(Y)||n__default.isMethodDeclaration(Y)||n__default.isFunctionTypeNode(Y))??!1}const ValidVitestFnCallChains=new Set(["beforeEach","beforeAll","afterEach","afterAll","it","it.skip","it.only","it.concurrent","it.sequential","it.todo","it.fails","it.extend","it.skipIf","it.runIf","it.each","it.skip.only","it.skip.concurrent","it.skip.sequential","it.skip.todo","it.skip.fails","it.only.skip","it.only.concurrent","it.only.sequential","it.only.todo","it.only.fails","it.concurrent.skip","it.concurrent.only","it.concurrent.sequential","it.concurrent.todo","it.concurrent.fails","it.sequential.skip","it.sequential.only","it.sequential.concurrent","it.sequential.todo","it.sequential.fails","it.todo.skip","it.todo.only","it.todo.concurrent","it.todo.sequential","it.todo.fails","it.fails.skip","it.fails.only","it.fails.concurrent","it.fails.sequential","it.fails.todo","it.extend.skip","it.extend.only","it.extend.concurrent","it.extend.sequential","it.extend.todo","it.extend.fails","it.skipIf.skip","it.skipIf.only","it.skipIf.concurrent","it.skipIf.sequential","it.skipIf.todo","it.skipIf.fails","it.runIf.skip","it.runIf.only","it.runIf.concurrent","it.runIf.sequential","it.runIf.todo","it.runIf.fails","it.skip.each","it.only.each","it.concurrent.each","it.sequential.each","it.todo.each","it.fails.each","it.extend.skipIf","it.extend.runIf","it.extend.each","it.skipIf.each","it.runIf.each","it.skip.only.concurrent","it.skip.only.sequential","it.skip.only.todo","it.skip.only.fails","it.skip.concurrent.only","it.skip.concurrent.sequential","it.skip.concurrent.todo","it.skip.concurrent.fails","it.skip.sequential.only","it.skip.sequential.concurrent","it.skip.sequential.todo","it.skip.sequential.fails","it.skip.todo.only","it.skip.todo.concurrent","it.skip.todo.sequential","it.skip.todo.fails","it.skip.fails.only","it.skip.fails.concurrent","it.skip.fails.sequential","it.skip.fails.todo","it.only.skip.concurrent","it.only.skip.sequential","it.only.skip.todo","it.only.skip.fails","it.only.concurrent.skip","it.only.concurrent.sequential","it.only.concurrent.todo","it.only.concurrent.fails","it.only.sequential.skip","it.only.sequential.concurrent","it.only.sequential.todo","it.only.sequential.fails","it.only.todo.skip","it.only.todo.concurrent","it.only.todo.sequential","it.only.todo.fails","it.only.fails.skip","it.only.fails.concurrent","it.only.fails.sequential","it.only.fails.todo","it.concurrent.skip.only","it.concurrent.skip.sequential","it.concurrent.skip.todo","it.concurrent.skip.fails","it.concurrent.only.skip","it.concurrent.only.sequential","it.concurrent.only.todo","it.concurrent.only.fails","it.concurrent.sequential.skip","it.concurrent.sequential.only","it.concurrent.sequential.todo","it.concurrent.sequential.fails","it.concurrent.todo.skip","it.concurrent.todo.only","it.concurrent.todo.sequential","it.concurrent.todo.fails","it.concurrent.fails.skip","it.concurrent.fails.only","it.concurrent.fails.sequential","it.concurrent.fails.todo","it.sequential.skip.only","it.sequential.skip.concurrent","it.sequential.skip.todo","it.sequential.skip.fails","it.sequential.only.skip","it.sequential.only.concurrent","it.sequential.only.todo","it.sequential.only.fails","it.sequential.concurrent.skip","it.sequential.concurrent.only","it.sequential.concurrent.todo","it.sequential.concurrent.fails","it.sequential.todo.skip","it.sequential.todo.only","it.sequential.todo.concurrent","it.sequential.todo.fails","it.sequential.fails.skip","it.sequential.fails.only","it.sequential.fails.concurrent","it.sequential.fails.todo","it.todo.skip.only","it.todo.skip.concurrent","it.todo.skip.sequential","it.todo.skip.fails","it.todo.only.skip","it.todo.only.concurrent","it.todo.only.sequential","it.todo.only.fails","it.todo.concurrent.skip","it.todo.concurrent.only","it.todo.concurrent.sequential","it.todo.concurrent.fails","it.todo.sequential.skip","it.todo.sequential.only","it.todo.sequential.concurrent","it.todo.sequential.fails","it.todo.fails.skip","it.todo.fails.only","it.todo.fails.concurrent","it.todo.fails.sequential","it.fails.skip.only","it.fails.skip.concurrent","it.fails.skip.sequential","it.fails.skip.todo","it.fails.only.skip","it.fails.only.concurrent","it.fails.only.sequential","it.fails.only.todo","it.fails.concurrent.skip","it.fails.concurrent.only","it.fails.concurrent.sequential","it.fails.concurrent.todo","it.fails.sequential.skip","it.fails.sequential.only","it.fails.sequential.concurrent","it.fails.sequential.todo","it.fails.todo.skip","it.fails.todo.only","it.fails.todo.concurrent","it.fails.todo.sequential","it.extend.skip.only","it.extend.skip.concurrent","it.extend.skip.sequential","it.extend.skip.todo","it.extend.skip.fails","it.extend.only.skip","it.extend.only.concurrent","it.extend.only.sequential","it.extend.only.todo","it.extend.only.fails","it.extend.concurrent.skip","it.extend.concurrent.only","it.extend.concurrent.sequential","it.extend.concurrent.todo","it.extend.concurrent.fails","it.extend.sequential.skip","it.extend.sequential.only","it.extend.sequential.concurrent","it.extend.sequential.todo","it.extend.sequential.fails","it.extend.todo.skip","it.extend.todo.only","it.extend.todo.concurrent","it.extend.todo.sequential","it.extend.todo.fails","it.extend.fails.skip","it.extend.fails.only","it.extend.fails.concurrent","it.extend.fails.sequential","it.extend.fails.todo","it.skipIf.skip.only","it.skipIf.skip.concurrent","it.skipIf.skip.sequential","it.skipIf.skip.todo","it.skipIf.skip.fails","it.skipIf.only.skip","it.skipIf.only.concurrent","it.skipIf.only.sequential","it.skipIf.only.todo","it.skipIf.only.fails","it.skipIf.concurrent.skip","it.skipIf.concurrent.only","it.skipIf.concurrent.sequential","it.skipIf.concurrent.todo","it.skipIf.concurrent.fails","it.skipIf.sequential.skip","it.skipIf.sequential.only","it.skipIf.sequential.concurrent","it.skipIf.sequential.todo","it.skipIf.sequential.fails","it.skipIf.todo.skip","it.skipIf.todo.only","it.skipIf.todo.concurrent","it.skipIf.todo.sequential","it.skipIf.todo.fails","it.skipIf.fails.skip","it.skipIf.fails.only","it.skipIf.fails.concurrent","it.skipIf.fails.sequential","it.skipIf.fails.todo","it.runIf.skip.only","it.runIf.skip.concurrent","it.runIf.skip.sequential","it.runIf.skip.todo","it.runIf.skip.fails","it.runIf.only.skip","it.runIf.only.concurrent","it.runIf.only.sequential","it.runIf.only.todo","it.runIf.only.fails","it.runIf.concurrent.skip","it.runIf.concurrent.only","it.runIf.concurrent.sequential","it.runIf.concurrent.todo","it.runIf.concurrent.fails","it.runIf.sequential.skip","it.runIf.sequential.only","it.runIf.sequential.concurrent","it.runIf.sequential.todo","it.runIf.sequential.fails","it.runIf.todo.skip","it.runIf.todo.only","it.runIf.todo.concurrent","it.runIf.todo.sequential","it.runIf.todo.fails","it.runIf.fails.skip","it.runIf.fails.only","it.runIf.fails.concurrent","it.runIf.fails.sequential","it.runIf.fails.todo","it.skip.only.each","it.skip.concurrent.each","it.skip.sequential.each","it.skip.todo.each","it.skip.fails.each","it.only.skip.each","it.only.concurrent.each","it.only.sequential.each","it.only.todo.each","it.only.fails.each","it.concurrent.skip.each","it.concurrent.only.each","it.concurrent.sequential.each","it.concurrent.todo.each","it.concurrent.fails.each","it.sequential.skip.each","it.sequential.only.each","it.sequential.concurrent.each","it.sequential.todo.each","it.sequential.fails.each","it.todo.skip.each","it.todo.only.each","it.todo.concurrent.each","it.todo.sequential.each","it.todo.fails.each","it.fails.skip.each","it.fails.only.each","it.fails.concurrent.each","it.fails.sequential.each","it.fails.todo.each","it.extend.skipIf.skip","it.extend.skipIf.only","it.extend.skipIf.concurrent","it.extend.skipIf.sequential","it.extend.skipIf.todo","it.extend.skipIf.fails","it.extend.runIf.skip","it.extend.runIf.only","it.extend.runIf.concurrent","it.extend.runIf.sequential","it.extend.runIf.todo","it.extend.runIf.fails","it.extend.skip.each","it.extend.only.each","it.extend.concurrent.each","it.extend.sequential.each","it.extend.todo.each","it.extend.fails.each","it.skipIf.skip.each","it.skipIf.only.each","it.skipIf.concurrent.each","it.skipIf.sequential.each","it.skipIf.todo.each","it.skipIf.fails.each","it.runIf.skip.each","it.runIf.only.each","it.runIf.concurrent.each","it.runIf.sequential.each","it.runIf.todo.each","it.runIf.fails.each","it.extend.skipIf.each","it.extend.runIf.each","test","test.skip","test.only","test.concurrent","test.sequential","test.todo","test.fails","test.extend","test.skipIf","test.runIf","test.each","test.skip.only","test.skip.concurrent","test.skip.sequential","test.skip.todo","test.skip.fails","test.only.skip","test.only.concurrent","test.only.sequential","test.only.todo","test.only.fails","test.concurrent.skip","test.concurrent.only","test.concurrent.sequential","test.concurrent.todo","test.concurrent.fails","test.sequential.skip","test.sequential.only","test.sequential.concurrent","test.sequential.todo","test.sequential.fails","test.todo.skip","test.todo.only","test.todo.concurrent","test.todo.sequential","test.todo.fails","test.fails.skip","test.fails.only","test.fails.concurrent","test.fails.sequential","test.fails.todo","test.extend.skip","test.extend.only","test.extend.concurrent","test.extend.sequential","test.extend.todo","test.extend.fails","test.skipIf.skip","test.skipIf.only","test.skipIf.concurrent","test.skipIf.sequential","test.skipIf.todo","test.skipIf.fails","test.runIf.skip","test.runIf.only","test.runIf.concurrent","test.runIf.sequential","test.runIf.todo","test.runIf.fails","test.skip.each","test.only.each","test.concurrent.each","test.sequential.each","test.todo.each","test.fails.each","test.extend.skipIf","test.extend.runIf","test.extend.each","test.skipIf.each","test.runIf.each","test.skip.only.concurrent","test.skip.only.sequential","test.skip.only.todo","test.skip.only.fails","test.skip.concurrent.only","test.skip.concurrent.sequential","test.skip.concurrent.todo","test.skip.concurrent.fails","test.skip.sequential.only","test.skip.sequential.concurrent","test.skip.sequential.todo","test.skip.sequential.fails","test.skip.todo.only","test.skip.todo.concurrent","test.skip.todo.sequential","test.skip.todo.fails","test.skip.fails.only","test.skip.fails.concurrent","test.skip.fails.sequential","test.skip.fails.todo","test.only.skip.concurrent","test.only.skip.sequential","test.only.skip.todo","test.only.skip.fails","test.only.concurrent.skip","test.only.concurrent.sequential","test.only.concurrent.todo","test.only.concurrent.fails","test.only.sequential.skip","test.only.sequential.concurrent","test.only.sequential.todo","test.only.sequential.fails","test.only.todo.skip","test.only.todo.concurrent","test.only.todo.sequential","test.only.todo.fails","test.only.fails.skip","test.only.fails.concurrent","test.only.fails.sequential","test.only.fails.todo","test.concurrent.skip.only","test.concurrent.skip.sequential","test.concurrent.skip.todo","test.concurrent.skip.fails","test.concurrent.only.skip","test.concurrent.only.sequential","test.concurrent.only.todo","test.concurrent.only.fails","test.concurrent.sequential.skip","test.concurrent.sequential.only","test.concurrent.sequential.todo","test.concurrent.sequential.fails","test.concurrent.todo.skip","test.concurrent.todo.only","test.concurrent.todo.sequential","test.concurrent.todo.fails","test.concurrent.fails.skip","test.concurrent.fails.only","test.concurrent.fails.sequential","test.concurrent.fails.todo","test.sequential.skip.only","test.sequential.skip.concurrent","test.sequential.skip.todo","test.sequential.skip.fails","test.sequential.only.skip","test.sequential.only.concurrent","test.sequential.only.todo","test.sequential.only.fails","test.sequential.concurrent.skip","test.sequential.concurrent.only","test.sequential.concurrent.todo","test.sequential.concurrent.fails","test.sequential.todo.skip","test.sequential.todo.only","test.sequential.todo.concurrent","test.sequential.todo.fails","test.sequential.fails.skip","test.sequential.fails.only","test.sequential.fails.concurrent","test.sequential.fails.todo","test.todo.skip.only","test.todo.skip.concurrent","test.todo.skip.sequential","test.todo.skip.fails","test.todo.only.skip","test.todo.only.concurrent","test.todo.only.sequential","test.todo.only.fails","test.todo.concurrent.skip","test.todo.concurrent.only","test.todo.concurrent.sequential","test.todo.concurrent.fails","test.todo.sequential.skip","test.todo.sequential.only","test.todo.sequential.concurrent","test.todo.sequential.fails","test.todo.fails.skip","test.todo.fails.only","test.todo.fails.concurrent","test.todo.fails.sequential","test.fails.skip.only","test.fails.skip.concurrent","test.fails.skip.sequential","test.fails.skip.todo","test.fails.only.skip","test.fails.only.concurrent","test.fails.only.sequential","test.fails.only.todo","test.fails.concurrent.skip","test.fails.concurrent.only","test.fails.concurrent.sequential","test.fails.concurrent.todo","test.fails.sequential.skip","test.fails.sequential.only","test.fails.sequential.concurrent","test.fails.sequential.todo","test.fails.todo.skip","test.fails.todo.only","test.fails.todo.concurrent","test.fails.todo.sequential","test.extend.skip.only","test.extend.skip.concurrent","test.extend.skip.sequential","test.extend.skip.todo","test.extend.skip.fails","test.extend.only.skip","test.extend.only.concurrent","test.extend.only.sequential","test.extend.only.todo","test.extend.only.fails","test.extend.concurrent.skip","test.extend.concurrent.only","test.extend.concurrent.sequential","test.extend.concurrent.todo","test.extend.concurrent.fails","test.extend.sequential.skip","test.extend.sequential.only","test.extend.sequential.concurrent","test.extend.sequential.todo","test.extend.sequential.fails","test.extend.todo.skip","test.extend.todo.only","test.extend.todo.concurrent","test.extend.todo.sequential","test.extend.todo.fails","test.extend.fails.skip","test.extend.fails.only","test.extend.fails.concurrent","test.extend.fails.sequential","test.extend.fails.todo","test.skipIf.skip.only","test.skipIf.skip.concurrent","test.skipIf.skip.sequential","test.skipIf.skip.todo","test.skipIf.skip.fails","test.skipIf.only.skip","test.skipIf.only.concurrent","test.skipIf.only.sequential","test.skipIf.only.todo","test.skipIf.only.fails","test.skipIf.concurrent.skip","test.skipIf.concurrent.only","test.skipIf.concurrent.sequential","test.skipIf.concurrent.todo","test.skipIf.concurrent.fails","test.skipIf.sequential.skip","test.skipIf.sequential.only","test.skipIf.sequential.concurrent","test.skipIf.sequential.todo","test.skipIf.sequential.fails","test.skipIf.todo.skip","test.skipIf.todo.only","test.skipIf.todo.concurrent","test.skipIf.todo.sequential","test.skipIf.todo.fails","test.skipIf.fails.skip","test.skipIf.fails.only","test.skipIf.fails.concurrent","test.skipIf.fails.sequential","test.skipIf.fails.todo","test.runIf.skip.only","test.runIf.skip.concurrent","test.runIf.skip.sequential","test.runIf.skip.todo","test.runIf.skip.fails","test.runIf.only.skip","test.runIf.only.concurrent","test.runIf.only.sequential","test.runIf.only.todo","test.runIf.only.fails","test.runIf.concurrent.skip","test.runIf.concurrent.only","test.runIf.concurrent.sequential","test.runIf.concurrent.todo","test.runIf.concurrent.fails","test.runIf.sequential.skip","test.runIf.sequential.only","test.runIf.sequential.concurrent","test.runIf.sequential.todo","test.runIf.sequential.fails","test.runIf.todo.skip","test.runIf.todo.only","test.runIf.todo.concurrent","test.runIf.todo.sequential","test.runIf.todo.fails","test.runIf.fails.skip","test.runIf.fails.only","test.runIf.fails.concurrent","test.runIf.fails.sequential","test.runIf.fails.todo","test.skip.only.each","test.skip.concurrent.each","test.skip.sequential.each","test.skip.todo.each","test.skip.fails.each","test.only.skip.each","test.only.concurrent.each","test.only.sequential.each","test.only.todo.each","test.only.fails.each","test.concurrent.skip.each","test.concurrent.only.each","test.concurrent.sequential.each","test.concurrent.todo.each","test.concurrent.fails.each","test.sequential.skip.each","test.sequential.only.each","test.sequential.concurrent.each","test.sequential.todo.each","test.sequential.fails.each","test.todo.skip.each","test.todo.only.each","test.todo.concurrent.each","test.todo.sequential.each","test.todo.fails.each","test.fails.skip.each","test.fails.only.each","test.fails.concurrent.each","test.fails.sequential.each","test.fails.todo.each","test.extend.skipIf.skip","test.extend.skipIf.only","test.extend.skipIf.concurrent","test.extend.skipIf.sequential","test.extend.skipIf.todo","test.extend.skipIf.fails","test.extend.runIf.skip","test.extend.runIf.only","test.extend.runIf.concurrent","test.extend.runIf.sequential","test.extend.runIf.todo","test.extend.runIf.fails","test.extend.skip.each","test.extend.only.each","test.extend.concurrent.each","test.extend.sequential.each","test.extend.todo.each","test.extend.fails.each","test.skipIf.skip.each","test.skipIf.only.each","test.skipIf.concurrent.each","test.skipIf.sequential.each","test.skipIf.todo.each","test.skipIf.fails.each","test.runIf.skip.each","test.runIf.only.each","test.runIf.concurrent.each","test.runIf.sequential.each","test.runIf.todo.each","test.runIf.fails.each","test.extend.skipIf.each","test.extend.runIf.each","bench","bench.skip","bench.only","bench.todo","bench.skipIf","bench.runIf","bench.skip.only","bench.skip.todo","bench.only.skip","bench.only.todo","bench.todo.skip","bench.todo.only","bench.skipIf.skip","bench.skipIf.only","bench.skipIf.todo","bench.runIf.skip","bench.runIf.only","bench.runIf.todo","bench.skip.only.todo","bench.skip.todo.only","bench.only.skip.todo","bench.only.todo.skip","bench.todo.skip.only","bench.todo.only.skip","bench.skipIf.skip.only","bench.skipIf.skip.todo","bench.skipIf.only.skip","bench.skipIf.only.todo","bench.skipIf.todo.skip","bench.skipIf.todo.only","bench.runIf.skip.only","bench.runIf.skip.todo","bench.runIf.only.skip","bench.runIf.only.todo","bench.runIf.todo.skip","bench.runIf.todo.only","describe","describe.skip","describe.only","describe.concurrent","describe.sequential","describe.shuffle","describe.todo","describe.skipIf","describe.runIf","describe.each","describe.skip.only","describe.skip.concurrent","describe.skip.sequential","describe.skip.shuffle","describe.skip.todo","describe.only.skip","describe.only.concurrent","describe.only.sequential","describe.only.shuffle","describe.only.todo","describe.concurrent.skip","describe.concurrent.only","describe.concurrent.sequential","describe.concurrent.shuffle","describe.concurrent.todo","describe.sequential.skip","describe.sequential.only","describe.sequential.concurrent","describe.sequential.shuffle","describe.sequential.todo","describe.shuffle.skip","describe.shuffle.only","describe.shuffle.concurrent","describe.shuffle.sequential","describe.shuffle.todo","describe.todo.skip","describe.todo.only","describe.todo.concurrent","describe.todo.sequential","describe.todo.shuffle","describe.skipIf.skip","describe.skipIf.only","describe.skipIf.concurrent","describe.skipIf.sequential","describe.skipIf.shuffle","describe.skipIf.todo","describe.runIf.skip","describe.runIf.only","describe.runIf.concurrent","describe.runIf.sequential","describe.runIf.shuffle","describe.runIf.todo","describe.skip.each","describe.only.each","describe.concurrent.each","describe.sequential.each","describe.shuffle.each","describe.todo.each","describe.skipIf.each","describe.runIf.each","describe.skip.only.concurrent","describe.skip.only.sequential","describe.skip.only.shuffle","describe.skip.only.todo","describe.skip.concurrent.only","describe.skip.concurrent.sequential","describe.skip.concurrent.shuffle","describe.skip.concurrent.todo","describe.skip.sequential.only","describe.skip.sequential.concurrent","describe.skip.sequential.shuffle","describe.skip.sequential.todo","describe.skip.shuffle.only","describe.skip.shuffle.concurrent","describe.skip.shuffle.sequential","describe.skip.shuffle.todo","describe.skip.todo.only","describe.skip.todo.concurrent","describe.skip.todo.sequential","describe.skip.todo.shuffle","describe.only.skip.concurrent","describe.only.skip.sequential","describe.only.skip.shuffle","describe.only.skip.todo","describe.only.concurrent.skip","describe.only.concurrent.sequential","describe.only.concurrent.shuffle","describe.only.concurrent.todo","describe.only.sequential.skip","describe.only.sequential.concurrent","describe.only.sequential.shuffle","describe.only.sequential.todo","describe.only.shuffle.skip","describe.only.shuffle.concurrent","describe.only.shuffle.sequential","describe.only.shuffle.todo","describe.only.todo.skip","describe.only.todo.concurrent","describe.only.todo.sequential","describe.only.todo.shuffle","describe.concurrent.skip.only","describe.concurrent.skip.sequential","describe.concurrent.skip.shuffle","describe.concurrent.skip.todo","describe.concurrent.only.skip","describe.concurrent.only.sequential","describe.concurrent.only.shuffle","describe.concurrent.only.todo","describe.concurrent.sequential.skip","describe.concurrent.sequential.only","describe.concurrent.sequential.shuffle","describe.concurrent.sequential.todo","describe.concurrent.shuffle.skip","describe.concurrent.shuffle.only","describe.concurrent.shuffle.sequential","describe.concurrent.shuffle.todo","describe.concurrent.todo.skip","describe.concurrent.todo.only","describe.concurrent.todo.sequential","describe.concurrent.todo.shuffle","describe.sequential.skip.only","describe.sequential.skip.concurrent","describe.sequential.skip.shuffle","describe.sequential.skip.todo","describe.sequential.only.skip","describe.sequential.only.concurrent","describe.sequential.only.shuffle","describe.sequential.only.todo","describe.sequential.concurrent.skip","describe.sequential.concurrent.only","describe.sequential.concurrent.shuffle","describe.sequential.concurrent.todo","describe.sequential.shuffle.skip","describe.sequential.shuffle.only","describe.sequential.shuffle.concurrent","describe.sequential.shuffle.todo","describe.sequential.todo.skip","describe.sequential.todo.only","describe.sequential.todo.concurrent","describe.sequential.todo.shuffle","describe.shuffle.skip.only","describe.shuffle.skip.concurrent","describe.shuffle.skip.sequential","describe.shuffle.skip.todo","describe.shuffle.only.skip","describe.shuffle.only.concurrent","describe.shuffle.only.sequential","describe.shuffle.only.todo","describe.shuffle.concurrent.skip","describe.shuffle.concurrent.only","describe.shuffle.concurrent.sequential","describe.shuffle.concurrent.todo","describe.shuffle.sequential.skip","describe.shuffle.sequential.only","describe.shuffle.sequential.concurrent","describe.shuffle.sequential.todo","describe.shuffle.todo.skip","describe.shuffle.todo.only","describe.shuffle.todo.concurrent","describe.shuffle.todo.sequential","describe.todo.skip.only","describe.todo.skip.concurrent","describe.todo.skip.sequential","describe.todo.skip.shuffle","describe.todo.only.skip","describe.todo.only.concurrent","describe.todo.only.sequential","describe.todo.only.shuffle","describe.todo.concurrent.skip","describe.todo.concurrent.only","describe.todo.concurrent.sequential","describe.todo.concurrent.shuffle","describe.todo.sequential.skip","describe.todo.sequential.only","describe.todo.sequential.concurrent","describe.todo.sequential.shuffle","describe.todo.shuffle.skip","describe.todo.shuffle.only","describe.todo.shuffle.concurrent","describe.todo.shuffle.sequential","describe.skipIf.skip.only","describe.skipIf.skip.concurrent","describe.skipIf.skip.sequential","describe.skipIf.skip.shuffle","describe.skipIf.skip.todo","describe.skipIf.only.skip","describe.skipIf.only.concurrent","describe.skipIf.only.sequential","describe.skipIf.only.shuffle","describe.skipIf.only.todo","describe.skipIf.concurrent.skip","describe.skipIf.concurrent.only","describe.skipIf.concurrent.sequential","describe.skipIf.concurrent.shuffle","describe.skipIf.concurrent.todo","describe.skipIf.sequential.skip","describe.skipIf.sequential.only","describe.skipIf.sequential.concurrent","describe.skipIf.sequential.shuffle","describe.skipIf.sequential.todo","describe.skipIf.shuffle.skip","describe.skipIf.shuffle.only","describe.skipIf.shuffle.concurrent","describe.skipIf.shuffle.sequential","describe.skipIf.shuffle.todo","describe.skipIf.todo.skip","describe.skipIf.todo.only","describe.skipIf.todo.concurrent","describe.skipIf.todo.sequential","describe.skipIf.todo.shuffle","describe.runIf.skip.only","describe.runIf.skip.concurrent","describe.runIf.skip.sequential","describe.runIf.skip.shuffle","describe.runIf.skip.todo","describe.runIf.only.skip","describe.runIf.only.concurrent","describe.runIf.only.sequential","describe.runIf.only.shuffle","describe.runIf.only.todo","describe.runIf.concurrent.skip","describe.runIf.concurrent.only","describe.runIf.concurrent.sequential","describe.runIf.concurrent.shuffle","describe.runIf.concurrent.todo","describe.runIf.sequential.skip","describe.runIf.sequential.only","describe.runIf.sequential.concurrent","describe.runIf.sequential.shuffle","describe.runIf.sequential.todo","describe.runIf.shuffle.skip","describe.runIf.shuffle.only","describe.runIf.shuffle.concurrent","describe.runIf.shuffle.sequential","describe.runIf.shuffle.todo","describe.runIf.todo.skip","describe.runIf.todo.only","describe.runIf.todo.concurrent","describe.runIf.todo.sequential","describe.runIf.todo.shuffle","describe.skip.only.each","describe.skip.concurrent.each","describe.skip.sequential.each","describe.skip.shuffle.each","describe.skip.todo.each","describe.only.skip.each","describe.only.concurrent.each","describe.only.sequential.each","describe.only.shuffle.each","describe.only.todo.each","describe.concurrent.skip.each","describe.concurrent.only.each","describe.concurrent.sequential.each","describe.concurrent.shuffle.each","describe.concurrent.todo.each","describe.sequential.skip.each","describe.sequential.only.each","describe.sequential.concurrent.each","describe.sequential.shuffle.each","describe.sequential.todo.each","describe.shuffle.skip.each","describe.shuffle.only.each","describe.shuffle.concurrent.each","describe.shuffle.sequential.each","describe.shuffle.todo.each","describe.todo.skip.each","describe.todo.only.each","describe.todo.concurrent.each","describe.todo.sequential.each","describe.todo.shuffle.each","describe.skipIf.skip.each","describe.skipIf.only.each","describe.skipIf.concurrent.each","describe.skipIf.sequential.each","describe.skipIf.shuffle.each","describe.skipIf.todo.each","describe.runIf.skip.each","describe.runIf.only.each","describe.runIf.concurrent.each","describe.runIf.sequential.each","describe.runIf.shuffle.each","describe.runIf.todo.each","suite","suite.skip","suite.only","suite.concurrent","suite.sequential","suite.shuffle","suite.todo","suite.skipIf","suite.runIf","suite.each","suite.skip.only","suite.skip.concurrent","suite.skip.sequential","suite.skip.shuffle","suite.skip.todo","suite.only.skip","suite.only.concurrent","suite.only.sequential","suite.only.shuffle","suite.only.todo","suite.concurrent.skip","suite.concurrent.only","suite.concurrent.sequential","suite.concurrent.shuffle","suite.concurrent.todo","suite.sequential.skip","suite.sequential.only","suite.sequential.concurrent","suite.sequential.shuffle","suite.sequential.todo","suite.shuffle.skip","suite.shuffle.only","suite.shuffle.concurrent","suite.shuffle.sequential","suite.shuffle.todo","suite.todo.skip","suite.todo.only","suite.todo.concurrent","suite.todo.sequential","suite.todo.shuffle","suite.skipIf.skip","suite.skipIf.only","suite.skipIf.concurrent","suite.skipIf.sequential","suite.skipIf.shuffle","suite.skipIf.todo","suite.runIf.skip","suite.runIf.only","suite.runIf.concurrent","suite.runIf.sequential","suite.runIf.shuffle","suite.runIf.todo","suite.skip.each","suite.only.each","suite.concurrent.each","suite.sequential.each","suite.shuffle.each","suite.todo.each","suite.skipIf.each","suite.runIf.each","suite.skip.only.concurrent","suite.skip.only.sequential","suite.skip.only.shuffle","suite.skip.only.todo","suite.skip.concurrent.only","suite.skip.concurrent.sequential","suite.skip.concurrent.shuffle","suite.skip.concurrent.todo","suite.skip.sequential.only","suite.skip.sequential.concurrent","suite.skip.sequential.shuffle","suite.skip.sequential.todo","suite.skip.shuffle.only","suite.skip.shuffle.concurrent","suite.skip.shuffle.sequential","suite.skip.shuffle.todo","suite.skip.todo.only","suite.skip.todo.concurrent","suite.skip.todo.sequential","suite.skip.todo.shuffle","suite.only.skip.concurrent","suite.only.skip.sequential","suite.only.skip.shuffle","suite.only.skip.todo","suite.only.concurrent.skip","suite.only.concurrent.sequential","suite.only.concurrent.shuffle","suite.only.concurrent.todo","suite.only.sequential.skip","suite.only.sequential.concurrent","suite.only.sequential.shuffle","suite.only.sequential.todo","suite.only.shuffle.skip","suite.only.shuffle.concurrent","suite.only.shuffle.sequential","suite.only.shuffle.todo","suite.only.todo.skip","suite.only.todo.concurrent","suite.only.todo.sequential","suite.only.todo.shuffle","suite.concurrent.skip.only","suite.concurrent.skip.sequential","suite.concurrent.skip.shuffle","suite.concurrent.skip.todo","suite.concurrent.only.skip","suite.concurrent.only.sequential","suite.concurrent.only.shuffle","suite.concurrent.only.todo","suite.concurrent.sequential.skip","suite.concurrent.sequential.only","suite.concurrent.sequential.shuffle","suite.concurrent.sequential.todo","suite.concurrent.shuffle.skip","suite.concurrent.shuffle.only","suite.concurrent.shuffle.sequential","suite.concurrent.shuffle.todo","suite.concurrent.todo.skip","suite.concurrent.todo.only","suite.concurrent.todo.sequential","suite.concurrent.todo.shuffle","suite.sequential.skip.only","suite.sequential.skip.concurrent","suite.sequential.skip.shuffle","suite.sequential.skip.todo","suite.sequential.only.skip","suite.sequential.only.concurrent","suite.sequential.only.shuffle","suite.sequential.only.todo","suite.sequential.concurrent.skip","suite.sequential.concurrent.only","suite.sequential.concurrent.shuffle","suite.sequential.concurrent.todo","suite.sequential.shuffle.skip","suite.sequential.shuffle.only","suite.sequential.shuffle.concurrent","suite.sequential.shuffle.todo","suite.sequential.todo.skip","suite.sequential.todo.only","suite.sequential.todo.concurrent","suite.sequential.todo.shuffle","suite.shuffle.skip.only","suite.shuffle.skip.concurrent","suite.shuffle.skip.sequential","suite.shuffle.skip.todo","suite.shuffle.only.skip","suite.shuffle.only.concurrent","suite.shuffle.only.sequential","suite.shuffle.only.todo","suite.shuffle.concurrent.skip","suite.shuffle.concurrent.only","suite.shuffle.concurrent.sequential","suite.shuffle.concurrent.todo","suite.shuffle.sequential.skip","suite.shuffle.sequential.only","suite.shuffle.sequential.concurrent","suite.shuffle.sequential.todo","suite.shuffle.todo.skip","suite.shuffle.todo.only","suite.shuffle.todo.concurrent","suite.shuffle.todo.sequential","suite.todo.skip.only","suite.todo.skip.concurrent","suite.todo.skip.sequential","suite.todo.skip.shuffle","suite.todo.only.skip","suite.todo.only.concurrent","suite.todo.only.sequential","suite.todo.only.shuffle","suite.todo.concurrent.skip","suite.todo.concurrent.only","suite.todo.concurrent.sequential","suite.todo.concurrent.shuffle","suite.todo.sequential.skip","suite.todo.sequential.only","suite.todo.sequential.concurrent","suite.todo.sequential.shuffle","suite.todo.shuffle.skip","suite.todo.shuffle.only","suite.todo.shuffle.concurrent","suite.todo.shuffle.sequential","suite.skipIf.skip.only","suite.skipIf.skip.concurrent","suite.skipIf.skip.sequential","suite.skipIf.skip.shuffle","suite.skipIf.skip.todo","suite.skipIf.only.skip","suite.skipIf.only.concurrent","suite.skipIf.only.sequential","suite.skipIf.only.shuffle","suite.skipIf.only.todo","suite.skipIf.concurrent.skip","suite.skipIf.concurrent.only","suite.skipIf.concurrent.sequential","suite.skipIf.concurrent.shuffle","suite.skipIf.concurrent.todo","suite.skipIf.sequential.skip","suite.skipIf.sequential.only","suite.skipIf.sequential.concurrent","suite.skipIf.sequential.shuffle","suite.skipIf.sequential.todo","suite.skipIf.shuffle.skip","suite.skipIf.shuffle.only","suite.skipIf.shuffle.concurrent","suite.skipIf.shuffle.sequential","suite.skipIf.shuffle.todo","suite.skipIf.todo.skip","suite.skipIf.todo.only","suite.skipIf.todo.concurrent","suite.skipIf.todo.sequential","suite.skipIf.todo.shuffle","suite.runIf.skip.only","suite.runIf.skip.concurrent","suite.runIf.skip.sequential","suite.runIf.skip.shuffle","suite.runIf.skip.todo","suite.runIf.only.skip","suite.runIf.only.concurrent","suite.runIf.only.sequential","suite.runIf.only.shuffle","suite.runIf.only.todo","suite.runIf.concurrent.skip","suite.runIf.concurrent.only","suite.runIf.concurrent.sequential","suite.runIf.concurrent.shuffle","suite.runIf.concurrent.todo","suite.runIf.sequential.skip","suite.runIf.sequential.only","suite.runIf.sequential.concurrent","suite.runIf.sequential.shuffle","suite.runIf.sequential.todo","suite.runIf.shuffle.skip","suite.runIf.shuffle.only","suite.runIf.shuffle.concurrent","suite.runIf.shuffle.sequential","suite.runIf.shuffle.todo","suite.runIf.todo.skip","suite.runIf.todo.only","suite.runIf.todo.concurrent","suite.runIf.todo.sequential","suite.runIf.todo.shuffle","suite.skip.only.each","suite.skip.concurrent.each","suite.skip.sequential.each","suite.skip.shuffle.each","suite.skip.todo.each","suite.only.skip.each","suite.only.concurrent.each","suite.only.sequential.each","suite.only.shuffle.each","suite.only.todo.each","suite.concurrent.skip.each","suite.concurrent.only.each","suite.concurrent.sequential.each","suite.concurrent.shuffle.each","suite.concurrent.todo.each","suite.sequential.skip.each","suite.sequential.only.each","suite.sequential.concurrent.each","suite.sequential.shuffle.each","suite.sequential.todo.each","suite.shuffle.skip.each","suite.shuffle.only.each","suite.shuffle.concurrent.each","suite.shuffle.sequential.each","suite.shuffle.todo.each","suite.todo.skip.each","suite.todo.only.each","suite.todo.concurrent.each","suite.todo.sequential.each","suite.todo.shuffle.each","suite.skipIf.skip.each","suite.skipIf.only.each","suite.skipIf.concurrent.each","suite.skipIf.sequential.each","suite.skipIf.shuffle.each","suite.skipIf.todo.each","suite.runIf.skip.each","suite.runIf.only.each","suite.runIf.concurrent.each","suite.runIf.sequential.each","suite.runIf.shuffle.each","suite.runIf.todo.each","xtest","xtest.each","xit","xit.each","fit","xdescribe","xdescribe.each","fdescribe"]);function getScope(b,Y){return b.sourceCode.getScope?b.sourceCode.getScope(Y):b.getScope()}function getModuleScope(b,Y){let q=getScope(b,Y);for(;q;){if(q.type==="module")return q;q=q.upper}return q}const isTypeOfVitestFnCall=(b,Y,q)=>{const $=parseVitestFnCall(b,Y);return $!==null&&q.includes($.type)},parseVitestFnCall=(b,Y)=>{const q=parseVitestFnCallWithReason(b,Y);return typeof q=="string"?null:q},y$4=new WeakMap,parseVitestFnCallWithReason=(b,Y)=>{let q=y$4.get(b);return q||(q=M$3(b,Y),y$4.set(b,q),q)},A$3=b=>b==="expect"?"expect":b==="expectTypeOf"?"expectTypeOf":b==="vi"?"vi":b==="vitest"?"vitest":DescribeAlias.hasOwnProperty(b)?"describe":TestCaseName.hasOwnProperty(b)?"test":HookName.hasOwnProperty(b)?"hook":"unknown",w$2=b=>{const Y=[];for(const q of b){if(q.parent?.type===utils.AST_NODE_TYPES.MemberExpression&&q.parent.parent?.type===utils.AST_NODE_TYPES.CallExpression)return{matcher:q,args:q.parent.parent.arguments,modifiers:Y};const $=getAccessorValue(q);if(Y.length===0){if(!ModifierName.hasOwnProperty($))return"modifier-unknown"}else if(Y.length===1){if($!==ModifierName.not&&$!=ModifierName.have)return"modifier-unknown";const B=getAccessorValue(Y[0]);if(B!==ModifierName.resolves&&B!==ModifierName.rejects&&B!==ModifierName.to)return"modifier-unknown"}else return"modifier-unknown";Y.push(q)}return"matcher-not-found"},P$2=(b,Y)=>{const q=w$2(b.members);return typeof q=="string"?q:{...b,type:Y,...q}},findTopMostCallExpression=b=>{let Y=b,{parent:q}=b;for(;q;){if(q.type===utils.AST_NODE_TYPES.CallExpression){Y=q,q=q.parent;continue}if(q.type!==utils.AST_NODE_TYPES.MemberExpression)break;q=q.parent}return Y},M$3=(b,Y)=>{const q=getNodeChain(b);if(!q?.length)return null;const[$,...B]=q,F=getAccessorValue(q[q.length-1]);if(F==="each"&&b.callee.type!==utils.AST_NODE_TYPES.CallExpression&&b.callee.type!==utils.AST_NODE_TYPES.TaggedTemplateExpression||b.callee.type===utils.AST_NODE_TYPES.TaggedTemplateExpression&&F!=="each")return null;const W=v(Y,b,getAccessorValue($));if(!W)return null;const V=W.original??W.local,H=[V,...B.map(getAccessorValue)];if(W.type!=="testContext"&&V!=="vi"&&V!=="vitest"&&V!=="expect"&&V!=="expectTypeOf"&&!ValidVitestFnCallChains.has(H.join(".")))return null;const X={name:V,head:{...W,node:$},members:B},z=A$3(V);if(z==="expect"||z==="expectTypeOf"){const G=P$2(X,z);return typeof G=="string"&&findTopMostCallExpression(b)!==b?null:G==="matcher-not-found"&&b.parent?.type===utils.AST_NODE_TYPES.MemberExpression?"matcher-not-called":G}return q.slice(0,q.length-1).some(G=>G.parent?.type!==utils.AST_NODE_TYPES.MemberExpression)||b.parent?.type===utils.AST_NODE_TYPES.CallExpression||b.parent?.type===utils.AST_NODE_TYPES.MemberExpression?null:{...X,type:z}},k$1=(b,Y)=>b&&Y?[...b,...Y]:null;function getNodeChain(b){if(isSupportedAccessor(b))return[b];switch(b.type){case utils.AST_NODE_TYPES.TaggedTemplateExpression:return getNodeChain(b.tag);case utils.AST_NODE_TYPES.MemberExpression:return k$1(getNodeChain(b.object),getNodeChain(b.property));case utils.AST_NODE_TYPES.CallExpression:return getNodeChain(b.callee)}return null}const v=(b,Y,q)=>{const $=getScope(b,Y),B=resolveScope($,q);return B==="local"?null:B==="testContext"?{local:q,original:null,type:"testContext"}:B?B.source==="vitest"?{original:B.imported,local:B.local,type:"import"}:null:{original:N$5(q,b),local:q,type:"global"}},N$5=(b,Y)=>{const q=Y.settings.vitest?.globalAliases??{},$=Object.entries(q).find(([B,F])=>F.includes(b));return $?$[0]:null},I$1=({parent:b})=>{if(b?.type===utils.AST_NODE_TYPES.CallExpression&&b.callee.type===utils.AST_NODE_TYPES.Identifier)return TestCaseName.hasOwnProperty(b.callee.name)},resolveScope=(b,Y)=>{let q=b;for(;q!==null;){const $=q.set.get(Y);if($&&$.defs.length>0){const B=$.defs[$.defs.length-1],F=isFunction(B.node)?B.node.params.find(H=>H.type===utils.AST_NODE_TYPES.ObjectPattern):void 0;if(F){const H=F.properties.find(X=>X.type===utils.AST_NODE_TYPES.Property);if((H?.key.type===utils.AST_NODE_TYPES.Identifier?H.key:void 0)?.name===Y)return"testContext"}const W=isFunction(B.node)?B.node.params.find(H=>H.type===utils.AST_NODE_TYPES.Identifier):void 0;if(W&&I$1(W.parent))return"testContext";const V=D$1(B);return V?.local===Y?V:"local"}q=q.upper}return null},R=b=>b.type===utils.AST_NODE_TYPES.AwaitExpression?b.argument.type===utils.AST_NODE_TYPES.ImportExpression?b.argument.source:null:b.type===utils.AST_NODE_TYPES.CallExpression&&isIdentifier(b.callee,"require")?b.arguments[0]??null:null,O$2=b=>b.parent.type===utils.AST_NODE_TYPES.TSImportEqualsDeclaration||b.node.type!==utils.AST_NODE_TYPES.ImportSpecifier||b.node.imported.type!=utils.AST_NODE_TYPES.Identifier||b.parent.importKind==="type"?null:{source:b.parent.source.value,imported:b.node.imported.name,local:b.node.local.name},D$1=b=>b.type==="Variable"?L$1(b):b.type==="ImportBinding"?O$2(b):null,L$1=b=>{if(!b.node.init)return null;const Y=R(b.node.init);return!Y||!isStringNode(Y)||b.name.parent?.type!==utils.AST_NODE_TYPES.Property||!isSupportedAccessor(b.name.parent.key)?null:{source:getStringValue(Y),imported:getAccessorValue(b.name.parent.key),local:b.name.name}},getTestCallExpressionsFromDeclaredVariables=(b,Y)=>b.reduce((q,{references:$})=>q.concat($.map(({identifier:B})=>B.parent).filter(B=>B?.type===utils.AST_NODE_TYPES.CallExpression&&isTypeOfVitestFnCall(B,Y,["test"]))),[]),getFirstMatcherArg=b=>{const[Y]=b.args;return Y.type===utils.AST_NODE_TYPES.SpreadElement?Y:followTypeAssertionChain$1(Y)},K=b=>b.type===utils.AST_NODE_TYPES.TSAsExpression||b.type===utils.AST_NODE_TYPES.TSTypeAssertion,followTypeAssertionChain$1=b=>K(b)?followTypeAssertionChain$1(b.expression):b,RULE_NAME$18="prefer-lowercase-title",E$4=b=>b.arguments[0]&&isStringNode(b.arguments[0]),x$4=b=>{const Y=[];return b.includes(DescribeAlias.describe)&&Y.push(...Object.keys(DescribeAlias)),b.includes(TestCaseName.test)&&Y.push(...Object.keys(TestCaseName).filter(q=>q.endsWith(TestCaseName.test))),b.includes(TestCaseName.it)&&Y.push(...Object.keys(TestCaseName).filter(q=>q.endsWith(TestCaseName.it))),Y},ge=createEslintRule({name:RULE_NAME$18,meta:{type:"problem",docs:{description:"enforce lowercase titles",recommended:!1},fixable:"code",messages:{lowerCaseTitle:"`{{ method }}`s should begin with lowercase",fullyLowerCaseTitle:"`{{ method }}`s should be lowercase"},schema:[{type:"object",properties:{ignore:{type:"array",items:{type:"string",enum:[DescribeAlias.describe,TestCaseName.test,TestCaseName.it]}},allowedPrefixes:{type:"array",items:{type:"string"},additionalItems:!1},ignoreTopLevelDescribe:{type:"boolean",default:!1},lowercaseFirstCharacterOnly:{type:"boolean",default:!0}},additionalProperties:!1}]},defaultOptions:[{ignore:[],allowedPrefixes:[],ignoreTopLevelDescribe:!1,lowercaseFirstCharacterOnly:!0}],create:(b,[{ignore:Y=[],allowedPrefixes:q=[],ignoreTopLevelDescribe:$=!1,lowercaseFirstCharacterOnly:B=!1}])=>{const F=x$4(Y);let W=0;return{CallExpression(V){const H=parseVitestFnCall(V,b);if(!H||!E$4)return;if(H?.type==="describe"){if(W++,$&&W===1)return}else if(H?.type!=="test")return;const[X]=V.arguments,z=getStringValue(X);if(typeof z!="string"||q.some(ee=>z.startsWith(ee)))return;const G=z.charAt(0);F.includes(H.name)||B&&(!G||G===G.toLowerCase())||!B&&z===z.toLowerCase()||b.report({messageId:B?"lowerCaseTitle":"fullyLowerCaseTitle",node:V.arguments[0],data:{method:H.name},fix:ee=>{const J=getStringValue(X),se=[X.range[0]+1,X.range[1]-1],Q=B?J.substring(0,1).toLowerCase()+J.substring(1):J.toLowerCase();return[ee.replaceTextRange(se,Q)]}})},"CallExpression:exit"(V){isTypeOfVitestFnCall(V,b,["describe"])&&W--}}}}),RULE_NAME$17="max-nested-describe",ke=createEslintRule({name:RULE_NAME$17,meta:{type:"problem",docs:{description:"require describe block to be less than set max value or default value",recommended:!1},schema:[{type:"object",properties:{max:{type:"number"}},additionalProperties:!1}],messages:{maxNestedDescribe:"Nested describe block should be less than set max value"}},defaultOptions:[{max:5}],create(b,[{max:Y}]){const q=[];function $(F){F.parent?.type==="CallExpression"&&(F.parent.callee.type!=="Identifier"||F.parent.callee.name!=="describe"||(q.push(0),q.length>Y&&b.report({node:F.parent,messageId:"maxNestedDescribe"})))}function B(F){F.parent?.type==="CallExpression"&&(F.parent.callee.type!=="Identifier"||F.parent.callee.name!=="describe"||q.pop())}return{FunctionExpression:$,"FunctionExpression:exit":B,ArrowFunctionExpression:$,"ArrowFunctionExpression:exit":B}}}),RULE_NAME$16="no-identical-title",c$6=()=>({describeTitles:[],testTitles:[]}),xe=createEslintRule({name:RULE_NAME$16,meta:{type:"problem",docs:{description:"disallow identical titles",recommended:!1},fixable:"code",schema:[],messages:{multipleTestTitle:"Test is used multiple times in the same describe(suite) block",multipleDescribeTitle:"Describe is used multiple times in the same describe(suite) block"}},defaultOptions:[],create(b){const Y=[c$6()];return{CallExpression(q){const $=Y[Y.length-1],B=parseVitestFnCall(q,b);if(!B||((B.name==="describe"||B.name==="suite")&&Y.push(c$6()),B.members.find(V=>isSupportedAccessor(V,"each"))))return;const[F]=q.arguments;if(!F||!isStringNode(F))return;const W=getStringValue(F);B.type==="test"&&($?.testTitles.includes(W)&&b.report({node:q,messageId:"multipleTestTitle"}),$?.testTitles.push(W)),B.type==="describe"&&($?.describeTitles.includes(W)&&b.report({node:q,messageId:"multipleDescribeTitle"}),$?.describeTitles.push(W))},"CallExpression:exit"(q){isTypeOfVitestFnCall(q,b,["describe"])&&Y.pop()}}}}),RULE_NAME$15="no-focused-tests",n$2=b=>b.type==="Identifier"&&["it","test","describe"].includes(b.name),a$6=b=>b.type==="Identifier"&&b.name==="only",Ce=createEslintRule({name:RULE_NAME$15,meta:{type:"problem",docs:{description:"disallow focused tests",recommended:!1},fixable:"code",schema:[{type:"object",properties:{fixable:{type:"boolean",default:!0}},additionalProperties:!1}],messages:{noFocusedTests:"Focused tests are not allowed"}},defaultOptions:[{fixable:!0}],create:b=>{const Y=b.options[0]?.fixable;return{ExpressionStatement(q){if(q.expression.type==="CallExpression"){const{callee:$}=q.expression;if($.type==="MemberExpression"&&n$2($.object)&&a$6($.property)&&b.report({node:$.property,messageId:"noFocusedTests",fix:B=>Y?B.removeRange([$.property.range[0]-1,$.property.range[1]]):null}),$.type==="TaggedTemplateExpression"){const B=$.tag.type==="MemberExpression"?$.tag.object:null;if(!B)return;B.type==="MemberExpression"&&n$2(B.object)&&a$6(B.property)&&b.report({node:B.property,messageId:"noFocusedTests",fix:F=>Y?F.removeRange([B.property.range[0]-1,B.property.range[1]]):null})}}},CallExpression(q){if(q.callee.type==="CallExpression"){const{callee:$}=q.callee;if($.type==="MemberExpression"&&$.object.type==="MemberExpression"&&n$2($.object.object)&&a$6($.object.property)&&$.property.type==="Identifier"&&$.property.name==="each"){const B=$.object.property;b.report({node:$.object.property,messageId:"noFocusedTests",fix:F=>Y?F.removeRange([B.range[0]-1,B.range[1]]):null})}}}}}}),RULE_NAME$14="no-conditional-tests",ve=createEslintRule({name:RULE_NAME$14,meta:{type:"problem",docs:{description:"disallow conditional tests",recommended:!1},schema:[],messages:{noConditionalTests:"Avoid using if conditions in a test"}},defaultOptions:[],create(b){return{Identifier:function(Y){["test","it","describe"].includes(Y.name)&&Y.parent?.parent?.parent?.parent?.type==="IfStatement"&&b.report({node:Y,messageId:"noConditionalTests"})}}}}),i$2={typecheck:!1};function parsePluginSettings(b){const Y=typeof b.vitest!="object"||b.vitest===null?{}:b.vitest;return{...i$2,...Y}}const RULE_NAME$13="expect-expect",Be=createEslintRule({name:RULE_NAME$13,meta:{type:"suggestion",docs:{description:"enforce having expectation in test body",recommended:!1},schema:[{type:"object",properties:{assertFunctionNames:{type:"array",items:{type:"string"}},additionalTestBlockFunctions:{type:"array",items:{type:"string"}}},additionalProperties:!1}],messages:{noAssertions:"Test has no assertions"}},defaultOptions:[{assertFunctionNames:["expect","assert"],additionalTestBlockFunctions:[]}],create(b,[{assertFunctionNames:Y=["expect"],additionalTestBlockFunctions:q=[]}]){const $=[];parsePluginSettings(b.settings).typecheck&&Y.push("expectTypeOf","assertType");const B=Y.map(x$3);function F(W){for(const V of W){const H=V.type===utils.AST_NODE_TYPES.CallExpression?$.indexOf(V):-1;if(V.type===utils.AST_NODE_TYPES.FunctionDeclaration){const X=b.sourceCode.getDeclaredVariables(V),z=getTestCallExpressionsFromDeclaredVariables(X,b);F(z)}if(H!==-1){$.splice(H,1);break}}}return{CallExpression(W){if(W.callee.type===utils.AST_NODE_TYPES.Identifier&&W.callee.name==="bench"||W?.callee?.type===utils.AST_NODE_TYPES.MemberExpression&&W.callee.property.type===utils.AST_NODE_TYPES.Identifier&&W.callee.property.name==="extend"||W?.callee?.type===utils.AST_NODE_TYPES.MemberExpression&&W.callee.property.type===utils.AST_NODE_TYPES.Identifier&&W.callee.property.name==="skip")return;const V=getNodeName(W)??"";if(isTypeOfVitestFnCall(W,b,["test"])||q.includes(V)){if(W.callee.type===utils.AST_NODE_TYPES.MemberExpression&&isSupportedAccessor(W.callee.property,"todo"))return;$.push(W)}else B.some(H=>H.test(V))&&F(b.sourceCode.getAncestors(W))},"Program:exit"(){$.forEach(W=>{b.report({node:W.callee,messageId:"noAssertions"})})}}}});function x$3(b){const Y=b.split(".").map(q=>q==="**"?"[_a-z\\d\\.]*":q.replace(/\*/gu,"[a-z\\d]*"));return new RegExp(`^${Y.join("\\.")}(\\.|$)`,"ui")}const RULE_NAME$12="hoisted-apis-on-top",c$5=["mock","hoisted","unmock"],ye=createEslintRule({name:RULE_NAME$12,meta:{hasSuggestions:!0,type:"suggestion",docs:{description:"enforce hoisted APIs to be on top of the file"},messages:{hoistedApisOnTop:"Hoisted API is used in a runtime location in this file, but it is actually executed before this file is loaded.",suggestMoveHoistedApiToTop:"Move this hoisted API to the top of the file to better reflect its behavior.",suggestReplaceMockWithDoMock:"Replace 'vi.mock()' with 'vi.doMock()', which is not hoisted."},schema:[]},defaultOptions:[],create(b){let Y=null;const q=[];return{ImportDeclaration($){$.parent.type===utils.AST_NODE_TYPES.Program&&(Y=$.range[1])},CallExpression($){if($.callee.type!==utils.AST_NODE_TYPES.MemberExpression)return;const{object:B,property:F}=$.callee;if(B.type!==utils.AST_NODE_TYPES.Identifier||B.name!=="vi"||F.type!==utils.AST_NODE_TYPES.Identifier)return;const W=F.name;if(c$5.includes(W)){if(W==="hoisted"){let V=$.parent;if(V?.type===utils.AST_NODE_TYPES.AwaitExpression&&(V=V.parent),V?.type===utils.AST_NODE_TYPES.VariableDeclarator&&(V=V.parent),(V?.type===utils.AST_NODE_TYPES.ExpressionStatement||V?.type===utils.AST_NODE_TYPES.VariableDeclaration)&&V.parent?.type===utils.AST_NODE_TYPES.Program)return}else if($.parent?.type===utils.AST_NODE_TYPES.ExpressionStatement&&$.parent.parent?.type===utils.AST_NODE_TYPES.Program)return;q.push($)}},"Program:exit"(){for(const $ of q){const B=[];B.push({messageId:"suggestMoveHoistedApiToTop",*fix(W){$.parent.type===utils.AST_NODE_TYPES.ExpressionStatement?yield W.remove($):yield W.replaceText($,"undefined"),Y!=null?yield W.insertTextAfterRange([Y,Y],`
`+b.sourceCode.getText($)+";"):yield W.insertTextAfterRange([0,0],b.sourceCode.getText($)+`;
`)}});const F=$.callee.property;F.name==="mock"&&B.push({messageId:"suggestReplaceMockWithDoMock",fix(W){return W.replaceText(F,"doMock")}}),b.report({node:$,messageId:"hoistedApisOnTop",suggest:B})}}}}}),RULE_NAME$11="consistent-test-it",g$2=(b,Y,q)=>$=>[$.replaceText(b.type===utils.AST_NODE_TYPES.MemberExpression?b.object:b,E$3(Y,q))];function E$3(b,Y){return b===TestCaseName.fit?"test.only":b.startsWith("f")||b.startsWith("x")?b.charAt(0)+Y:Y}function u$4(b){return b===TestCaseName.test?TestCaseName.it:TestCaseName.test}const Ie=createEslintRule({name:RULE_NAME$11,meta:{type:"suggestion",fixable:"code",docs:{description:"enforce using test or it but not both",recommended:!1},messages:{consistentMethod:"Prefer using {{ testFnKeyWork }} instead of {{ oppositeTestKeyword }}",consistentMethodWithinDescribe:"Prefer using {{ testKeywordWithinDescribe }} instead of {{ oppositeTestKeyword }} within describe"},schema:[{type:"object",properties:{fn:{type:"string",enum:[TestCaseName.test,TestCaseName.it]},withinDescribe:{type:"string",enum:[TestCaseName.test,TestCaseName.it]}},additionalProperties:!1}]},defaultOptions:[{fn:TestCaseName.test,withinDescribe:TestCaseName.it}],create(b){const Y=b.options[0]??{},q=Y.fn||TestCaseName.test,$=Y?.withinDescribe||Y?.fn||TestCaseName?.it,B=q===$?q:void 0;let F=0;return{ImportDeclaration(W){if(B==null||W.source.type!=="Literal"||W.source.value!=="vitest")return;const V=u$4(B);for(const H of W.specifiers)H.type==="ImportSpecifier"&&H.imported.type==="Identifier"&&H.local.name===H.imported.name&&H.local.name===V&&b.report({node:H,data:{testFnKeyWork:q,oppositeTestKeyword:V},messageId:"consistentMethod",fix:X=>{const z=W.specifiers.filter(G=>G.local.name!==V);if(z.length>0){const G=z.map(J=>J.local.name).join(", "),ee=W.specifiers.at(-1)?.range;return ee?X.replaceTextRange([W.specifiers[0].range[0],ee[1]],G):null}return X.replaceText(H.local,B)}})},CallExpression(W){if(W.callee.type===utils.AST_NODE_TYPES.Identifier&&W.callee.name==="bench")return;const V=parseVitestFnCall(W,b);if(!V)return;if(V.type==="describe"){F++;return}const H=W.callee.type===utils.AST_NODE_TYPES.TaggedTemplateExpression?W.callee.tag:W.callee.type===utils.AST_NODE_TYPES.CallExpression?W.callee.callee:W.callee;if(V.type==="test"&&F===0&&!V.name.endsWith(q)){const X=u$4(q);b.report({node:W.callee,data:{testFnKeyWork:q,oppositeTestKeyword:X},messageId:"consistentMethod",fix:g$2(H,V.name,q)})}else if(V.type==="test"&&F>0&&!V.name.endsWith($)){const X=u$4($);b.report({messageId:"consistentMethodWithinDescribe",node:W.callee,data:{testKeywordWithinDescribe:$,oppositeTestKeyword:X},fix:g$2(H,V.name,$)})}},"CallExpression:exit"(W){isTypeOfVitestFnCall(W,b,["describe"])&&F--}}}}),RULE_NAME$10="consistent-vitest-vi",d=b=>b===UtilName.vi?UtilName.vitest:UtilName.vi,Se=createEslintRule({name:RULE_NAME$10,meta:{type:"suggestion",fixable:"code",docs:{description:"enforce using vitest or vi but not both",recommended:!1},messages:{consistentUtil:"Prefer using {{ utilKeyword }} instead of {{ oppositeUtilKeyword }}"},schema:[{type:"object",properties:{fn:{type:"string",enum:[UtilName.vi,UtilName.vitest]}},additionalProperties:!1}]},defaultOptions:[{fn:UtilName.vi}],create(b){const Y=(b.options[0]??{}).fn||UtilName.vi,q=d(Y);return{ImportDeclaration($){if(!($.source.type!==utils.AST_NODE_TYPES.Literal||$.source.value!=="vitest"))for(const B of $.specifiers)B.type===utils.AST_NODE_TYPES.ImportSpecifier&&B.imported.type===utils.AST_NODE_TYPES.Identifier&&B.local.name===B.imported.name&&B.imported.name===q&&b.report({node:B,messageId:"consistentUtil",data:{utilKeyword:Y,oppositeUtilKeyword:q},fix:F=>{const W=$.specifiers.filter(V=>V.local.name!==q);if(W.length>0){const V=W.map(X=>X.local.name).join(", "),H=$.specifiers.at(-1)?.range;return H?F.replaceTextRange([$.specifiers[0].range[0],H[1]],V):null}return F.replaceText(B.local,Y)}})},CallExpression($){if(parseVitestFnCall($,b)?.type!==q)return;const B=$.callee.type===utils.AST_NODE_TYPES.MemberExpression?$.callee.object:$.callee;b.report({node:B,data:{utilKeyword:Y,oppositeUtilKeyword:q},messageId:"consistentUtil",fix:F=>F.replaceText(B,Y)})}}}}),RULE_NAME$$="prefer-to-be",E$2=b=>b.type===utils.AST_NODE_TYPES.Literal&&b.value===null,N$4=b=>E$2(getFirstMatcherArg(b)),c$4=(b,Y)=>isIdentifier(getFirstMatcherArg(b),Y),h$2=b=>Math.floor(b)!==Math.ceil(b),y$3=b=>{let Y=getFirstMatcherArg(b);return Y.type===utils.AST_NODE_TYPES.Literal&&typeof Y.value=="number"&&h$2(Y.value)?!1:(Y.type===utils.AST_NODE_TYPES.UnaryExpression&&Y.operator==="-"&&(Y=Y.argument),Y.type===utils.AST_NODE_TYPES.Literal?!("regex"in Y):Y.type===utils.AST_NODE_TYPES.TemplateLiteral)},o$2=(b,Y,q,$,B)=>{b.report({messageId:`useToBe${Y}`,fix(F){const W=[replaceAccessorFixer(F,q.matcher,`toBe${Y}`)];return q.args?.length&&Y!==""&&W.push(removeExtraArgumentsFixer(F,b,$,0)),B&&W.push(F.removeRange([B.range[0]-1,B.range[1]])),W},node:q.matcher})},Oe=createEslintRule({name:RULE_NAME$$,meta:{type:"suggestion",docs:{description:"enforce using toBe()",recommended:!1},schema:[],fixable:"code",messages:{useToBe:"Use `toBe` instead",useToBeUndefined:"Use `toBeUndefined()` instead",useToBeDefined:"Use `toBeDefined()` instead",useToBeNull:"Use `toBeNull()` instead",useToBeNaN:"Use `toBeNaN()` instead"}},defaultOptions:[],create(b){return{CallExpression(Y){const q=parseVitestFnCall(Y,b);if(q?.type!=="expect")return;const $=getAccessorValue(q.matcher),B=q.modifiers.find(F=>getAccessorValue(F)==="not");if(B&&["toBeUndefined","toBeDefined"].includes($)){o$2(b,$==="toBeDefined"?"Undefined":"Defined",q,Y,B);return}if(!(!EqualityMatcher.hasOwnProperty($)||q.args.length===0)){if(N$4(q)){o$2(b,"Null",q,Y);return}if(c$4(q,"undefined")){o$2(b,B?"Defined":"Undefined",q,Y);return}if(c$4(q,"NaN")){o$2(b,"NaN",q,Y);return}y$3(q)&&$!==EqualityMatcher.toBe&&o$2(b,"",q,Y)}}}}}),RULE_NAME$_="no-hooks",De=createEslintRule({name:RULE_NAME$_,meta:{type:"suggestion",docs:{description:"disallow setup and teardown hooks",recommended:!1},schema:[{type:"object",properties:{allow:{type:"array",contains:["beforeAll","beforeEach","afterAll","afterEach"]}},additionalProperties:!1}],messages:{unexpectedHook:"Unexpected '{{ hookName }}' hook"}},defaultOptions:[{allow:[]}],create(b,[{allow:Y=[]}]){return{CallExpression(q){const $=parseVitestFnCall(q,b);$?.type==="hook"&&!Y.includes($.name)&&b.report({node:q,messageId:"unexpectedHook",data:{hookName:$.name}})}}}}),RULE_NAME$Z="no-restricted-vi-methods",He=createEslintRule({name:RULE_NAME$Z,meta:{type:"suggestion",docs:{description:"disallow specific `vi.` methods",recommended:!1},schema:[{type:"object",additionalProperties:{type:["string","null"]}}],messages:{restrictedViMethod:"Use of `{{ restriction }}` is disallowed",restrictedViMethodWithMessage:"{{ message }}"}},defaultOptions:[{}],create(b,[Y]){return{CallExpression(q){const $=parseVitestFnCall(q,b);if($?.type!=="vi"||$.members.length===0)return;const B=getAccessorValue($.members[0]);if(B in Y){const F=Y[B];b.report({messageId:F?"restrictedViMethodWithMessage":"restrictedViMethod",data:{message:F,restriction:B},loc:{start:$.members[0].loc.start,end:$.members[$.members.length-1].loc.end}})}}}}}),RULE_NAME$Y="consistent-test-filename",o$1=/.*\.test\.[tj]sx?$/,e=/.*\.(test|spec)\.[tj]sx?$/,qe=createEslintRule({name:RULE_NAME$Y,meta:{type:"problem",docs:{recommended:!1,requiresTypeChecking:!1,description:"require .spec test file pattern"},messages:{consistentTestFilename:"Use test file name pattern {{ pattern }}"},schema:[{type:"object",additionalProperties:!1,properties:{pattern:{format:"regex",default:o$1.source},allTestPattern:{format:"regex",default:e.source}}}]},defaultOptions:[{pattern:e.source,allTestPattern:e.source}],create:b=>{const Y=b.options[0]??{},{pattern:q=o$1,allTestPattern:$=e}=Y,B=typeof q=="string"?new RegExp(q):q,F=typeof $=="string"?new RegExp($):$,{filename:W}=b;return F.test(W)?{Program:V=>{B.test(W)||b.report({node:V,messageId:"consistentTestFilename",data:{pattern:B.source}})}}:{}}}),RULE_NAME$X="max-expects",Fe=createEslintRule({name:RULE_NAME$X,meta:{docs:{requiresTypeChecking:!1,recommended:!1,description:"enforce a maximum number of expect per test"},messages:{maxExpect:"Too many assertion calls ({{ count }}) - maximum allowed is {{ max }}"},type:"suggestion",schema:[{type:"object",properties:{max:{type:"number"}},additionalProperties:!1}]},defaultOptions:[{max:5}],create(b,[{max:Y}]){let q=0;const $=B=>{(B.parent?.type!==utils.AST_NODE_TYPES.CallExpression||isTypeOfVitestFnCall(B.parent,b,["test"]))&&(q=0)};return{FunctionExpression:$,"FunctionExpression:exit":$,ArrowFunctionExpression:$,"ArrowFunctionExpression:exit":$,CallExpression(B){const F=parseVitestFnCall(B,b);F?.type!=="expect"||F.head.node.parent?.type===utils.AST_NODE_TYPES.MemberExpression||(q+=1,q>Y&&b.report({node:B,messageId:"maxExpect",data:{count:q,max:Y}}))}}}}),RULE_NAME$W="no-alias-methods",Ve=createEslintRule({name:RULE_NAME$W,meta:{docs:{description:"disallow alias methods",requiresTypeChecking:!1,recommended:!1},messages:{noAliasMethods:"Replace {{ alias }}() with its canonical name {{ canonical }}()"},type:"suggestion",fixable:"code",schema:[]},defaultOptions:[],create(b){const Y={toBeCalled:"toHaveBeenCalled",toBeCalledTimes:"toHaveBeenCalledTimes",toBeCalledWith:"toHaveBeenCalledWith",lastCalledWith:"toHaveBeenLastCalledWith",nthCalledWith:"toHaveBeenNthCalledWith",toReturn:"toHaveReturned",toReturnTimes:"toHaveReturnedTimes",toReturnWith:"toHaveReturnedWith",lastReturnedWith:"toHaveLastReturnedWith",nthReturnedWith:"toHaveNthReturnedWith",toThrowError:"toThrow"};return{CallExpression(q){const $=parseVitestFnCall(q,b);if($?.type!=="expect")return;const{matcher:B}=$,F=getAccessorValue(B);if(F in Y){const W=Y[F];b.report({messageId:"noAliasMethods",data:{alias:F,canonical:W},node:B,fix:V=>[replaceAccessorFixer(V,B,W)]})}}}}}),RULE_NAME$V="no-commented-out-tests";function n$1(b){return/^\s*[xf]?(test|it|describe)(\.\w+|\[['"]\w+['"]\])?\s*\(/mu.test(b.value)}const Pe=createEslintRule({name:RULE_NAME$V,meta:{docs:{description:"disallow commented out tests",requiresTypeChecking:!1,recommended:!1},messages:{noCommentedOutTests:"Remove commented out tests - you may want to use `skip` or `only` instead"},schema:[],type:"suggestion"},defaultOptions:[],create(b){const{sourceCode:Y}=b;function q($){n$1($)&&b.report({messageId:"noCommentedOutTests",node:$})}return{Program(){Y.getAllComments().forEach(q)}}}}),RULE_NAME$U="no-conditional-expect",r=b=>b.callee.type===utils.AST_NODE_TYPES.MemberExpression&&isSupportedAccessor(b.callee.property,"catch"),Ge=createEslintRule({name:RULE_NAME$U,meta:{type:"problem",docs:{description:"disallow conditional expects",requiresTypeChecking:!1,recommended:!1},messages:{noConditionalExpect:"Avoid calling `expect` inside conditional statements"},schema:[]},defaultOptions:[],create(b){let Y=0,q=!1,$=!1;const B=()=>q&&Y++,F=()=>q&&Y--;return{FunctionDeclaration(W){const V=b.sourceCode.getDeclaredVariables(W);getTestCallExpressionsFromDeclaredVariables(V,b).length>0&&(q=!0)},CallExpression(W){const{type:V}=parseVitestFnCall(W,b)??{};V==="test"&&(q=!0),r(W)&&($=!0),q&&V==="expect"&&Y>0&&b.report({messageId:"noConditionalExpect",node:W}),$&&V==="expect"&&b.report({messageId:"noConditionalExpect",node:W})},"CallExpression:exit"(W){isTypeOfVitestFnCall(W,b,["test"])&&(q=!1),r(W)&&($=!1)},CatchClause:B,"CatchClause:exit":F,IfStatement:B,"IfStatement:exit":F,SwitchStatement:B,"SwitchStatement:exit":F,ConditionalExpression:B,"ConditionalExpression:exit":F,LogicalExpression:B,"LogicalExpression:exit":F}}}),RULE_NAME$T="no-import-node-test",je=createEslintRule({name:RULE_NAME$T,meta:{docs:{description:"disallow importing `node:test`",recommended:!1},type:"suggestion",messages:{noImportNodeTest:"Import from `vitest` instead of `node:test`"},fixable:"code",schema:[]},defaultOptions:[],create(b){return{ImportDeclaration(Y){Y.source.value==="node:test"&&b.report({messageId:"noImportNodeTest",node:Y,fix:q=>q.replaceText(Y.source,Y.source.raw.replace("node:test","vitest"))})}}}}),VITEST_GLOBALS=new Set(["suite","test","chai","describe","it","expectTypeOf","assertType","expect","assert","vitest","vi","beforeAll","afterAll","beforeEach","afterEach","onTestFailed","onTestFinished"]),isVitestImport=b=>b.source.value==="vitest",isVitestGlobalsImportSpecifier=b=>b.type===utils.AST_NODE_TYPES.ImportSpecifier&&b.imported.type===utils.AST_NODE_TYPES.Identifier&&VITEST_GLOBALS.has(b.imported.name),isVitestGlobalsProperty=b=>b.type===utils.AST_NODE_TYPES.Property&&b.key.type===utils.AST_NODE_TYPES.Identifier&&VITEST_GLOBALS.has(b.key.name),isVitestGlobalsFunction=b=>b.callee.type===utils.AST_NODE_TYPES.Identifier&&VITEST_GLOBALS.has(b.callee.name),isRequireVitestCall=b=>{if(b?.type!==utils.AST_NODE_TYPES.CallExpression||b.callee.type!==utils.AST_NODE_TYPES.Identifier||b.callee.name!=="require")return!1;const Y=b.arguments;return Y.length===1&&Y[0].type===utils.AST_NODE_TYPES.Literal&&Y[0].value==="vitest"},isObjectPattern=b=>b.type===utils.AST_NODE_TYPES.ObjectPattern,removeVariableDeclarator=(b,Y)=>{const q=Y.parent,$=q.declarations;if($.length===1)return b.remove(q);const B=$.findIndex(F=>F.range[0]===Y.range[0]&&F.range[1]===Y.range[1]);if(B===0){const F=$[1];return b.removeRange([Y.range[0],F.range[0]])}else{const F=$[B-1];return b.removeRange([F.range[1],Y.range[1]])}},removeNodeFromArray=(b,Y,q)=>{const $=Y.indexOf(q);if($===-1)throw new Error("Target node not found in nodes array");if($===0){const B=Y[1];return b.removeRange([q.range[0],B.range[0]])}else{const B=Y[$-1];return b.removeRange([B.range[1],q.range[1]])}},RULE_NAME$S="no-importing-vitest-globals",Ke=createEslintRule({name:RULE_NAME$S,meta:{type:"suggestion",docs:{description:"disallow importing Vitest globals",recommended:!1},messages:{noImportingVitestGlobals:"Do not import '{{name}}' from 'vitest'. Use globals configuration instead.",noRequiringVitestGlobals:"Do not require '{{name}}' from 'vitest'. Use globals configuration instead."},fixable:"code",schema:[]},defaultOptions:[],create(b){return{ImportDeclaration(Y){if(!isVitestImport(Y))return;const q=Y.specifiers;for(const $ of q)isVitestGlobalsImportSpecifier($)&&b.report({node:$,messageId:"noImportingVitestGlobals",data:{name:$.imported.name},fix(B){return q.every(F=>isVitestGlobalsImportSpecifier(F))?B.remove(Y):removeNodeFromArray(B,q,$)}})},VariableDeclarator(Y){if(!isRequireVitestCall(Y.init)||!isObjectPattern(Y.id))return;const q=Y.id.properties;for(const $ of q)isVitestGlobalsProperty($)&&b.report({node:$,messageId:"noRequiringVitestGlobals",data:{name:$.key.name},fix(B){return q.every(F=>isVitestGlobalsProperty(F))?removeVariableDeclarator(B,Y):removeNodeFromArray(B,q,$)}})}}}}),RULE_NAME$R="prefer-importing-vitest-globals",$e=createEslintRule({name:RULE_NAME$R,meta:{type:"suggestion",docs:{description:"enforce importing Vitest globals",recommended:!1},messages:{preferImportingVitestGlobals:"Import '{{name}}' from 'vitest'"},schema:[],fixable:"code"},defaultOptions:[],create(b){const Y=new Set;let q,$;return{ImportDeclaration(B){if(!isVitestImport(B))return;const F=B.specifiers;for(const W of F)if(isVitestGlobalsImportSpecifier(W)){const V=W.imported.name;Y.add(V)}q=B.specifiers},VariableDeclarator(B){if(!isRequireVitestCall(B.init)||!isObjectPattern(B.id))return;const F=B.id.properties;for(const W of F)if(isVitestGlobalsProperty(W)){const V=W.key.name;Y.add(V)}$=F},CallExpression(B){if(!isVitestGlobalsFunction(B))return;const F=B.callee.name;if(Y.has(F))return;const W=b.sourceCode.getScope(B).set.get(F);W&&W.defs.length>0&&W.defs.some(V=>!(V.type==="ImportBinding"||V.type==="Variable"&&V.node.init&&isRequireVitestCall(V.node.init)))||b.report({node:B.callee,messageId:"preferImportingVitestGlobals",data:{name:F},fix(V){const H=b.sourceCode.ast;if(!q)if($){const G=$[$.length-1];return V.insertTextAfter(G,`, ${F}`)}else return V.insertTextBefore(H.body[0],`import { ${F} } from 'vitest';
`);if(q.find(G=>G.type==="ImportNamespaceSpecifier"))return V.insertTextBefore(H.body[0],`import { ${F} } from 'vitest';
`);const X=q.find(G=>G.type==="ImportDefaultSpecifier");if(X)return V.insertTextAfter(X,`, { ${F} }`);const z=q[q.length-1];return V.insertTextAfter(z,`, ${F}`)}})}}}}),RULE_NAME$Q="no-conditional-in-test",We=createEslintRule({name:RULE_NAME$Q,meta:{docs:{description:"disallow conditional tests",requiresTypeChecking:!1,recommended:!1},messages:{noConditionalInTest:"Remove conditional tests"},schema:[],type:"problem"},defaultOptions:[],create(b){return{IfStatement(Y){Y.parent?.parent?.parent?.type==="CallExpression"&&isTypeOfVitestFnCall(Y.parent?.parent?.parent,b,["test","it"])&&b.report({messageId:"noConditionalInTest",node:Y})}}}}),RULE_NAME$P="no-disabled-tests",ze=createEslintRule({name:RULE_NAME$P,meta:{type:"suggestion",docs:{description:"disallow disabled tests",recommended:!1},messages:{missingFunction:"Test is missing function argument",pending:"Call to pending()",pendingSuite:"Call to pending() within test suite",pendingTest:"Call to pending() within test",disabledSuite:"Disabled test suite - if you want to skip a test suite temporarily, use .todo() instead",disabledTest:"Disabled test - if you want to skip a test temporarily, use .todo() instead"},schema:[]},defaultOptions:[],create(b){let Y=0,q=0;return{CallExpression($){const B=parseVitestFnCall($,b);if(!B)return;B.type==="describe"&&Y++,B.type==="test"&&(q++,$.arguments.length<2&&B.members.every(W=>getAccessorValue(W)==="skip")&&b.report({messageId:"missingFunction",node:$}));const F=B.members.find(W=>getAccessorValue(W)==="skip");(B.name.startsWith("x")||F!==void 0)&&b.report({messageId:B.type==="describe"?"disabledSuite":"disabledTest",node:F??B.head.node})},"CallExpression:exit"($){const B=parseVitestFnCall($,b);B&&(B.type==="describe"&&Y--,B.type==="test"&&q--)},'CallExpression[callee.name="pending"]'($){const B=getScope(b,$);resolveScope(B,"pending")||(q>0?b.report({messageId:"pendingTest",node:$}):Y>0?b.report({messageId:"pendingSuite",node:$}):b.report({messageId:"pending",node:$}))}}}}),RULE_NAME$O="no-done-callback",P$1=(b,Y,q)=>{if(Y)return b.arguments[1];const $=parseVitestFnCall(b,q);return $?.type==="hook"&&b.arguments.length>=1?b.arguments[0]:$?.type==="test"&&b.arguments.length>=2?b.arguments[1]:null},Je=createEslintRule({name:RULE_NAME$O,meta:{type:"suggestion",docs:{description:"disallow using a callback in asynchronous tests and hooks",recommended:!1},deprecated:!0,schema:[],messages:{noDoneCallback:"Return a promise instead of relying on callback parameter",suggestWrappingInPromise:"Wrap in `new Promise({{ callback }} => ...`",useAwaitInsteadOfCallback:"Use `await` instead of callback in async function"},hasSuggestions:!0},defaultOptions:[],create(b){return{CallExpression(Y){const q=/\.each$|\.concurrent$/.test(getNodeName(Y.callee)??"");if(q&&Y.callee.type!==utils.AST_NODE_TYPES.TaggedTemplateExpression||b.sourceCode.getAncestors(Y).some(W=>W.type!==utils.AST_NODE_TYPES.CallExpression||!isTypeOfVitestFnCall(W,b,["describe","test"])?!1:W.callee.type===utils.AST_NODE_TYPES.MemberExpression&&isSupportedAccessor(W.callee.property,"concurrent")))return;const $=P$1(Y,q,b),B=Number(q);if(!$||!isFunction($)||$.params.length!==1+B)return;const F=$.params[B];if(F.type!==utils.AST_NODE_TYPES.Identifier){b.report({node:F,messageId:"noDoneCallback"});return}if($.async){b.report({node:F,messageId:"useAwaitInsteadOfCallback"});return}b.report({node:Y,messageId:"noDoneCallback",suggest:[{messageId:"suggestWrappingInPromise",data:{callback:F.name},fix(W){const{body:V,params:H}=$,{sourceCode:X}=b,z=X.getFirstToken(V),G=X.getLastToken(V),[ee]=H,J=H[H.length-1],se=X.getTokenBefore(ee);let Q=X.getTokenAfter(J);if(Q?.value===","&&(Q=X.getTokenAfter(Q)),!z||!G||!se||!Q)throw new Error(`Unexpected null when attempting to fix ${b.filename} - please file an issue at https://github/veritem/eslint-plugin-vitest`);let Z=W.replaceText(ee,"()");se.value==="("&&Q.value===")"&&(Z=W.removeRange([se.range[1],Q.range[0]]));let oe=`new Promise(${F.name} => `,ne=")",te=!0;return V.type===utils.AST_NODE_TYPES.BlockStatement&&(oe=`return ${oe}{`,ne+="}",te=!1),[Z,te?W.insertTextBefore(z,oe):W.insertTextAfter(z,oe),W.insertTextAfter(G,ne)]}}]})}}}}),RULE_NAME$N="no-duplicate-hooks",Qe=createEslintRule({name:RULE_NAME$N,meta:{docs:{recommended:!1,description:"disallow duplicate hooks and teardown hooks",requiresTypeChecking:!1},messages:{noDuplicateHooks:"Duplicate {{ hook }} in describe block"},schema:[],type:"suggestion"},defaultOptions:[],create(b){const Y=[{}];return{CallExpression(q){const $=parseVitestFnCall(q,b);if($?.type==="describe"&&Y.push({}),$?.type!=="hook")return;const B=Y[Y.length-1];B[$.name]||=0,B[$.name]+=1,B[$.name]>1&&b.report({messageId:"noDuplicateHooks",data:{hook:$.name},node:q})},"CallExpression:exit"(q){isTypeOfVitestFnCall(q,b,["describe"])&&Y.pop()}}}}),RULE_NAME$M="no-large-snapshots",m$5=(b,Y,{maxSize:q=50,allowedSnapshots:$={}})=>{const B=Y.loc.start.line,F=Y.loc.end.line-B;if(!Object.keys($).every(node_path.isAbsolute))throw new Error("All paths for allowedSnapshots must be absolute. You can use JS config and `path.resolve`");let W=!1;if(Y.type===utils.AST_NODE_TYPES.ExpressionStatement&&"left"in Y.expression&&Y.expression.left.type===utils.AST_NODE_TYPES.MemberExpression&&isSupportedAccessor(Y.expression.left.property)){const V=b.filename,H=$[V];if(H){const X=getAccessorValue(Y.expression.left.property);W=H.some(z=>z instanceof RegExp?z.test(X):X===z)}}!W&&F>q&&b.report({node:Y,messageId:q===0?"noSnapShot":"tooLongSnapShot",data:{lineCount:F,lineLimit:q}})},Xe=createEslintRule({name:RULE_NAME$M,meta:{docs:{description:"disallow large snapshots",recommended:!1},messages:{noSnapShot:"`{{ lineCount }}`s should begin with lowercase",tooLongSnapShot:"Expected vitest snapshot to be smaller than {{ lineLimit }} lines but was {{ lineCount }} lines long"},type:"suggestion",schema:[{type:"object",properties:{maxSize:{type:"number"},inlineMaxSize:{type:"number"},allowedSnapshots:{type:"object",additionalProperties:{type:"array"}}},additionalProperties:!1}]},defaultOptions:[{}],create(b,[Y]){return b.filename.endsWith(".snap")?{ExpressionStatement(q){m$5(b,q,Y)}}:{CallExpression(q){const $=parseVitestFnCall(q,b);$?.type==="expect"&&["toMatchInlineSnapshot","toThrowErrorMatchingInlineSnapshot"].includes(getAccessorValue($.matcher))&&$.args.length&&m$5(b,$.args[0],{...Y,maxSize:Y.inlineMaxSize??Y.maxSize})}}}}),RULE_NAME$L="no-interpolation-in-snapshots",Ye=createEslintRule({name:RULE_NAME$L,meta:{type:"problem",docs:{description:"disallow string interpolation in snapshots",recommended:!1},fixable:"code",schema:[],messages:{noInterpolationInSnapshots:"Do not use string interpolation in snapshots"}},defaultOptions:[],create(b){return{CallExpression(Y){const q=parseVitestFnCall(Y,b);q?.type==="expect"&&["toMatchInlineSnapshot","toThrowErrorMatchingInlineSnapshot"].includes(getAccessorValue(q.matcher))&&q.args.forEach($=>{$.type===utils.AST_NODE_TYPES.TemplateLiteral&&$.expressions.length>0&&b.report({messageId:"noInterpolationInSnapshots",node:$})})}}}}),t="__mocks__",p$1=b=>b.split(node_path.posix.sep).includes(t),s=b=>isStringNode(b)&&p$1(getStringValue(b)),RULE_NAME$K="no-mocks-import",Ze=createEslintRule({name:RULE_NAME$K,meta:{type:"problem",docs:{description:"disallow importing from __mocks__ directory",recommended:!1},messages:{noMocksImport:`Mocks should not be manually imported from a ${t} directory. Instead use \`vi.mock\` and import from the original module path`},schema:[]},defaultOptions:[],create(b){return{ImportDeclaration(Y){s(Y.source)&&b.report({node:Y,messageId:"noMocksImport"})},'CallExpression[callee.name="require"]'(Y){const[q]=Y.arguments;q&&s(q)&&b.report({node:q,messageId:"noMocksImport"})}}}}),RULE_NAME$J="no-restricted-matchers",l$2=(b,Y)=>ModifierName.hasOwnProperty(Y)||Y.endsWith(".not")?b.startsWith(Y):b===Y,er=createEslintRule({name:RULE_NAME$J,meta:{docs:{description:"disallow the use of certain matchers",recommended:!1},type:"suggestion",schema:[{type:"object",additionalProperties:{type:["string","null"]}}],messages:{restrictedChain:"use of {{ restriction }} is disallowed",restrictedChainWithMessage:"{{ message }}"}},defaultOptions:[{}],create(b,[Y]){return{CallExpression(q){const $=parseVitestFnCall(q,b);if($?.type!=="expect")return;const B=$.members.map(F=>getAccessorValue(F)).join(".");for(const[F,W]of Object.entries(Y))if(l$2(B,F)){b.report({messageId:W?"restrictedChainWithMessage":"restrictedChain",data:{message:W,restriction:F},loc:{start:$.members[0].loc.start,end:$.members[$.members.length-1].loc.end}});break}}}}}),RULE_NAME$I="no-standalone-expect",a$5=(b,Y)=>{const q=b.parent;if(!q)throw new Error("Unexpected block statement. If you feel like this is a bug report https://github.com/veritem/eslint-plugin-vitest/issues/new");if(q.type===utils.AST_NODE_TYPES.FunctionDeclaration)return"function";if(isFunction(q)&&q.parent){const $=q.parent;if($.type===utils.AST_NODE_TYPES.VariableDeclarator)return"function";if($.type===utils.AST_NODE_TYPES.CallExpression&&isTypeOfVitestFnCall($,Y,["describe"]))return"describe"}return null},rr=createEslintRule({name:RULE_NAME$I,meta:{docs:{description:"disallow using `expect` outside of `it` or `test` blocks",recommended:!1},type:"suggestion",messages:{noStandaloneExpect:"Expect must be called inside a test block"},schema:[{type:"object",properties:{additionalTestBlockFunctions:{type:"array",items:{type:"string"}}},additionalProperties:!1}]},defaultOptions:[{additionalTestBlockFunctions:[]}],create(b,[{additionalTestBlockFunctions:Y=[]}]){const q=[],$=B=>Y.includes(getNodeName(B)||"");return{CallExpression(B){const F=parseVitestFnCall(B,b);if(F?.type==="expect"){if(F.head.node.parent?.type===utils.AST_NODE_TYPES.MemberExpression&&F.members.length===1&&!["assertions","hasAssertions"].includes(getAccessorValue(F.members[0])))return;const W=q[q.length-1];(!W||W===DescribeAlias.describe)&&b.report({node:B,messageId:"noStandaloneExpect"});return}(F?.type==="test"||$(B))&&q.push("test"),B.callee.type===utils.AST_NODE_TYPES.TaggedTemplateExpression&&q.push("template")},"CallExpression:exit"(B){const F=q[q.length-1];(F==="test"&&(isTypeOfVitestFnCall(B,b,["test"])||$(B))&&B.callee.type!==utils.AST_NODE_TYPES.MemberExpression||F==="template"&&B.callee.type===utils.AST_NODE_TYPES.TaggedTemplateExpression)&&q.pop()},BlockStatement(B){const F=a$5(B,b);F&&q.push(F)},"BlockStatement:exit"(B){a$5(B,b)&&q.pop()},ArrowFunctionExpression(B){B.parent?.type!==utils.AST_NODE_TYPES.CallExpression&&q.push("arrow")},"ArrowFunctionExpression:exit"(){q[q.length-1]==="arrow"&&q.pop()}}}}),RULE_NAME$H="no-test-prefixes",or=createEslintRule({name:RULE_NAME$H,meta:{docs:{description:"disallow using the `f` and `x` prefixes in favour of `.only` and `.skip`",recommended:!1},type:"suggestion",messages:{usePreferredName:'Use "{{ preferredNodeName }}" instead'},fixable:"code",schema:[]},defaultOptions:[],create(b){return{CallExpression(Y){const q=parseVitestFnCall(Y,b);if(q?.type!=="describe"&&q?.type!=="test"||q.name[0]!=="f"&&q.name[0]!=="x")return;const $=[q.name.slice(1),q.name[0]==="f"?"only":"skip",...q.members.map(F=>getAccessorValue(F))].join("."),B=Y.callee.type===utils.AST_NODE_TYPES.TaggedTemplateExpression?Y.callee.tag:Y.callee.type===utils.AST_NODE_TYPES.CallExpression?Y.callee.callee:Y.callee;b.report({messageId:"usePreferredName",node:Y.callee,data:{preferredNodeName:$},fix:F=>[F.replaceText(B,$)]})}}}}),RULE_NAME$G="no-test-return-statement",u$3=b=>{const[,Y]=b;return Y&&isFunction(Y)&&Y.body.type===utils.AST_NODE_TYPES.BlockStatement?Y.body.body:[]},ar=createEslintRule({name:RULE_NAME$G,meta:{type:"problem",docs:{description:"disallow return statements in tests",recommended:!1},schema:[],messages:{noTestReturnStatement:"Return statements are not allowed in tests"}},defaultOptions:[],create(b){return{CallExpression(Y){if(!isTypeOfVitestFnCall(Y,b,["test"]))return;const q=u$3(Y.arguments).find($=>$.type===utils.AST_NODE_TYPES.ReturnStatement);q&&b.report({messageId:"noTestReturnStatement",node:q})},FunctionDeclaration(Y){const q=b.sourceCode.getDeclaredVariables(Y);if(getTestCallExpressionsFromDeclaredVariables(q,b).length===0)return;const $=Y.body.body.find(B=>B.type===utils.AST_NODE_TYPES.ReturnStatement);$&&b.report({messageId:"noTestReturnStatement",node:$})}}}}),RULE_NAME$F="prefer-called-with",tr=createEslintRule({name:RULE_NAME$F,meta:{docs:{description:"enforce using `toBeCalledWith()` or `toHaveBeenCalledWith()`",recommended:!1},messages:{preferCalledWith:"Prefer {{ matcherName }}With(/* expected args */)"},type:"suggestion",fixable:"code",schema:[]},defaultOptions:[],create(b){return{CallExpression(Y){const q=parseVitestFnCall(Y,b);if(q?.type!=="expect"||q.modifiers.some(F=>getAccessorValue(F)==="not"))return;const{matcher:$}=q,B=getAccessorValue($);["toBeCalled","toHaveBeenCalled"].includes(B)&&b.report({data:{matcherName:B},messageId:"preferCalledWith",node:$,fix:F=>[F.replaceText($,`${B}With`)]})}}}}),RULE_NAME$E="valid-title",_=b=>["f","x"].includes(b.charAt(0))?b.substring(1):b,S$4=b=>b.type===utils.AST_NODE_TYPES.TemplateLiteral?`\`${b.quasis[0].value.raw}\``:b.raw,N$3={type:"array",items:{type:"string"},minItems:1,maxItems:2,additionalItems:!1},c$3=b=>{const[Y,q]=Array.isArray(b)?b:[b];return[new RegExp(Y,"u"),q]};function j(b){return!!(b.flags&n__default.TypeFlags.StringLike)}const T$2=b=>{if(typeof b=="string"||Array.isArray(b)){const Y=c$3(b);return{describe:Y,test:Y,it:Y}}return{describe:b.describe?c$3(b.describe):null,test:b.test?c$3(b.test):null,it:b.it?c$3(b.it):null}},A$2=b=>isStringNode(b.right)?!0:b.left.type===utils.AST_NODE_TYPES.BinaryExpression?A$2(b.left):isStringNode(b.left),sr=createEslintRule({name:RULE_NAME$E,meta:{docs:{description:"enforce valid titles",recommended:!1},messages:{titleMustBeString:"Test title must be a string, a function or class name",emptyTitle:"{{ functionName }} should not have an empty title",duplicatePrefix:"should not have duplicate prefix",accidentalSpace:"should not have leading or trailing spaces",disallowedWord:'"{{ word }}" is not allowed in test title',mustNotMatch:"{{ functionName }} should not match {{ pattern }}",mustMatch:"{{ functionName }} should match {{ pattern }}",mustNotMatchCustom:"{{ message }}",mustMatchCustom:"{{ message }}"},type:"suggestion",schema:[{type:"object",properties:{ignoreTypeOfDescribeName:{type:"boolean",default:!1},allowArguments:{type:"boolean",default:!1},disallowedWords:{type:"array",items:{type:"string"}}},patternProperties:{[/^must(?:Not)?Match$/u.source]:{oneOf:[{type:"string"},N$3,{type:"object",propertyNames:{type:"string",enum:["describe","test","it"]},additionalProperties:{oneOf:[{type:"string"},N$3]}}]}},additionalProperties:!1}],fixable:"code"},defaultOptions:[{ignoreTypeOfDescribeName:!1,allowArguments:!1,disallowedWords:[]}],create(b,[{ignoreTypeOfDescribeName:Y,allowArguments:q,disallowedWords:$=[],mustNotMatch:B,mustMatch:F}]){const W=new RegExp(`\\b(${$.join("|")})\\b`,"iu"),V=T$2(B??{}),H=T$2(F??{}),X=parsePluginSettings(b.settings);return{CallExpression(z){const G=parseVitestFnCall(z,b);if(G?.type!=="describe"&&G?.type!=="test"&&G?.type!=="it"||G.members&&G.members[0]&&G.members[0].type===utils.AST_NODE_TYPES.Identifier&&G.members[0].name==="extend")return;const ee=ie=>{b.report({messageId:"emptyTitle",data:{functionName:G.type==="describe"?DescribeAlias.describe:TestCaseName.test},node:ie})},[J]=z.arguments,se=X.typecheck?utils.ESLintUtils.getParserServices(b).getTypeAtLocation(J):null;if(se&&isClassOrFunctionType(se)||!J||q&&J.type===utils.AST_NODE_TYPES.Identifier)return;if(!isStringNode(J)){if(J.type===utils.AST_NODE_TYPES.BinaryExpression&&A$2(J)||se&&j(se))return;J.type!==utils.AST_NODE_TYPES.TemplateLiteral&&!(Y&&G.type==="describe")&&b.report({messageId:"titleMustBeString",loc:J.loc});return}const Q=getStringValue(J);if(!Q){ee(z);return}if($.length>0){const ie=W.exec(Q);if(ie){b.report({messageId:"disallowedWord",data:{word:ie[1]},node:J});return}}Q.trim().length!==Q.length&&b.report({messageId:"accidentalSpace",node:J,fix:ie=>[ie.replaceTextRange(J.range,S$4(J).replace(/^([`'"]) +?/u,"$1").replace(/ +?([`'"])$/u,"$1"))]});const Z=_(G.name),[oe]=Q.split(" ");oe.toLowerCase()===Z&&b.report({messageId:"duplicatePrefix",node:J,fix:ie=>[ie.replaceTextRange(J.range,S$4(J).replace(/^([`'"]).+? /u,"$1"))]});const ne=Z,[te,re]=V[ne]??[];if(te&&te.test(Q)){b.report({messageId:re?"mustNotMatchCustom":"mustNotMatch",node:J,data:{functionName:ne,pattern:te,message:re}});return}const[ae,ce]=H[ne]??[];ae&&(ae.test(Q)||b.report({messageId:ce?"mustMatchCustom":"mustMatch",node:J,data:{functionName:ne,pattern:ae,message:ce}}))}}}}),RULE_NAME$D="valid-expect",h$1=["toReject","toResolve"],D=b=>(b.type===utils.AST_NODE_TYPES.ArrayExpression&&b.parent&&b.parent.type===utils.AST_NODE_TYPES.CallExpression&&(b=b.parent),b.type===utils.AST_NODE_TYPES.CallExpression&&b.callee.type===utils.AST_NODE_TYPES.MemberExpression&&isSupportedAccessor(b.callee.object,"Promise")&&b.parent?b:null),A$1=({start:b,end:Y})=>`${b.line}:${b.column}-${Y.line}:${Y.column}`,O$1=b=>b.parent.type===utils.AST_NODE_TYPES.Property&&b.type===utils.AST_NODE_TYPES.FunctionExpression?b.parent:b;function M$2(b){const Y=b.parent?.parent;return Y&&Y.type===utils.AST_NODE_TYPES.CallExpression&&Y.callee.type===utils.AST_NODE_TYPES.MemberExpression&&isSupportedAccessor(Y.callee.property)&&["then","catch"].includes(getAccessorValue(Y.callee.property))&&Y.parent?M$2(Y):b}const U=b=>b.parent?.parent&&[utils.AST_NODE_TYPES.CallExpression,utils.AST_NODE_TYPES.ArrayExpression].includes(b.parent.type)?D(b.parent):null,N$2=({parent:b})=>b?isFunction(b)?b:N$2(b):null,w$1=(b,Y)=>Y&&b.type===utils.AST_NODE_TYPES.ReturnStatement?!0:b.type===utils.AST_NODE_TYPES.ConditionalExpression&&b.parent?w$1(b.parent,Y):[utils.AST_NODE_TYPES.ArrowFunctionExpression,utils.AST_NODE_TYPES.AwaitExpression].includes(b.type),nr=createEslintRule({name:RULE_NAME$D,meta:{docs:{description:"enforce valid `expect()` usage",recommended:!1},messages:{tooManyArgs:"Expect takes at most {{ amount}} argument{{ s }}",notEnoughArgs:"Expect requires at least {{ amount }} argument{{ s }}",modifierUnknown:"Expect has an unknown modifier",matcherNotFound:"Expect must have a corresponding matcher call",matcherNotCalled:"Matchers must be called to assert",asyncMustBeAwaited:"Async assertions must be awaited{{ orReturned }}",promisesWithAsyncAssertionsMustBeAwaited:"Promises which return async assertions must be awaited{{ orReturned }}"},type:"suggestion",fixable:"code",schema:[{type:"object",properties:{alwaysAwait:{type:"boolean",default:!1},asyncMatchers:{type:"array",items:{type:"string"}},minArgs:{type:"number",minimum:1},maxArgs:{type:"number",minimum:1}},additionalProperties:!1}]},defaultOptions:[{alwaysAwait:!1,asyncMatchers:h$1,minArgs:1,maxArgs:1}],create:(b,[{alwaysAwait:Y,asyncMatchers:q=h$1,minArgs:$=1,maxArgs:B=1}])=>{const F=new Set,W=[],V=z=>F.add(A$1(z)),H=z=>F.has(A$1(z)),X=z=>{let G=z,{parent:ee}=z;for(;ee&&ee.type===utils.AST_NODE_TYPES.MemberExpression;)G=ee,ee=ee.parent;return G};return{CallExpression(z){const G=parseVitestFnCallWithReason(z,b),ee=parsePluginSettings(b.settings);if(typeof G=="string"){const re=z.parent?.type===utils.AST_NODE_TYPES.MemberExpression?X(z.parent).property:z;if(G==="matcher-not-found"){b.report({messageId:"matcherNotFound",node:re});return}if(G==="matcher-not-called"&&b.report({messageId:isSupportedAccessor(re)&&ModifierName.hasOwnProperty(getAccessorValue(re))?"matcherNotFound":"matcherNotCalled",node:re}),G==="modifier-unknown"){b.report({messageId:"modifierUnknown",node:re});return}return}else if(G?.type==="expectTypeOf"&&ee.typecheck||G?.type!=="expect"||G.modifiers.some(re=>re.type===utils.AST_NODE_TYPES.Identifier&&re.name=="to"))return;const{parent:J}=G.head.node;if(J?.type!==utils.AST_NODE_TYPES.CallExpression)return;if(J.arguments.length<$){const re=getAccessorValue(G.head.node).length,ae={start:{column:J.loc.start.column+re,line:J.loc.start.line},end:{column:J.loc.start.column+re+1,line:J.loc.start.line}};b.report({messageId:"notEnoughArgs",data:{amount:$,s:$===1?"":"s"},node:J,loc:ae})}if(J.arguments.length>B){if(J.arguments.length===2){const ie=J.arguments[1].type===utils.AST_NODE_TYPES.Literal&&typeof J.arguments[1].value=="string",le=J.arguments[1].type===utils.AST_NODE_TYPES.TemplateLiteral;if(ie||le)return}const{start:re}=J.arguments[B].loc,{end:ae}=J.arguments[J.arguments.length-1].loc,ce={start:re,end:{column:ae.column+1,line:ae.line}};b.report({messageId:"tooManyArgs",data:{amount:B,s:B===1?"":"s"},node:J,loc:ce})}const{matcher:se}=G,Q=se.parent.parent,Z=G.modifiers.some(re=>getAccessorValue(re)!=="not")||q.includes(getAccessorValue(se));if(!Q?.parent||!Z)return;const oe=Q.parent.type===utils.AST_NODE_TYPES.ArrayExpression,ne=M$2(Q),te=U(ne)||ne;te.parent&&!w$1(te.parent,!Y)&&!H(te.loc)&&(W.push({messageId:te===ne?"asyncMustBeAwaited":"promisesWithAsyncAssertionsMustBeAwaited",node:te}),oe&&V(te.loc))},"Program:exit"(){const z=[];W.forEach(({node:G,messageId:ee},J)=>{const se=Y?"":" or returned";b.report({loc:G.loc,data:{orReturned:se},messageId:ee,node:G,fix(Q){const Z=N$2(G);if(!Z)return null;const oe=z.some(te=>te.text==="async ");if(!Z.async&&!oe){const te=O$1(Z);z.push(Q.insertTextBefore(te,"async "))}const ne=G.parent?.type===utils.AST_NODE_TYPES.ReturnStatement?G.parent:null;if(Y&&ne){const te=b.sourceCode.getText(ne).replace("return","await");z.push(Q.replaceText(ne,te))}else z.push(Q.insertTextBefore(G,"await "));return J===W.length-1?z:null}})})}}}}),isBooleanLiteral=b=>b.type===utils.AST_NODE_TYPES.Literal&&typeof b.value=="boolean",isBooleanEqualityMatcher=b=>{const Y=getAccessorValue(b.matcher);if(["toBeTruthy","toBeFalsy"].includes(Y))return!0;if(b.args.length!==1)return!1;const q=getFirstMatcherArg(b);return EqualityMatcher.hasOwnProperty(Y)&&isBooleanLiteral(q)},isInstanceOfBinaryExpression=(b,Y)=>b.type===utils.AST_NODE_TYPES.BinaryExpression&&b.operator==="instanceof"&&isSupportedAccessor(b.right,Y),hasOnlyOneArgument=b=>b.arguments.length===1,RULE_NAME$C="prefer-to-be-object",ir=createEslintRule({name:RULE_NAME$C,meta:{type:"suggestion",docs:{description:"enforce using toBeObject()",recommended:!1},fixable:"code",messages:{preferToBeObject:"Prefer toBeObject() to test if a value is an object"},schema:[]},defaultOptions:[],create(b){return{CallExpression(Y){const q=parseVitestFnCall(Y,b);if(q?.type!=="expectTypeOf")return;if(isParsedInstanceOfMatcherCall(q,"Object")){b.report({node:q.matcher,messageId:"preferToBeObject",fix:F=>[F.replaceTextRange([q.matcher.range[0],q.matcher.range[1]+8],"toBeObject()")]});return}const{parent:$}=q.head.node;if($?.type!==utils.AST_NODE_TYPES.CallExpression)return;const[B]=$.arguments;!B||!isBooleanEqualityMatcher(q)||!isInstanceOfBinaryExpression(B,"Object")||b.report({node:q.matcher,messageId:"preferToBeObject",fix(F){const W=[F.replaceText(q.matcher,"toBeObject"),F.removeRange([B.left.range[1],B.range[1]])];let V=getAccessorValue(q.matcher)==="toBeFalsy";if(q.args.length){const[H]=q.args;W.push(F.remove(H)),V=H.type===utils.AST_NODE_TYPES.Literal&&followTypeAssertionChain$1(H).value===!1}if(V){const H=q.modifiers.find(X=>getAccessorValue(X)==="not");W.push(H?F.removeRange([H.range[0]-1,H.range[1]]):F.insertTextBefore(q.matcher,"not."))}return W}})}}}}),RULE_NAME$B="prefer-to-be-truthy",n=b=>b.type===utils.AST_NODE_TYPES.Literal&&b.value===!0,mr=createEslintRule({name:RULE_NAME$B,meta:{type:"suggestion",docs:{description:"enforce using `toBeTruthy`",recommended:!1},messages:{preferToBeTruthy:"Prefer using `toBeTruthy` to test value is `true`"},fixable:"code",schema:[]},defaultOptions:[],create(b){return{CallExpression(Y){const q=parseVitestFnCall(Y,b);(q?.type==="expect"||q?.type==="expectTypeOf")&&q.args.length===1&&n(getFirstMatcherArg(q))&&EqualityMatcher.hasOwnProperty(getAccessorValue(q.matcher))&&b.report({node:q.matcher,messageId:"preferToBeTruthy",fix:$=>[$.replaceText(q.matcher,"toBeTruthy"),$.remove(q.args[0])]})}}}}),RULE_NAME$A="prefer-to-be-falsy",c$2=b=>b.type===utils.AST_NODE_TYPES.Literal&&b.value===!1,pr=createEslintRule({name:RULE_NAME$A,meta:{type:"suggestion",docs:{description:"enforce using toBeFalsy()",recommended:!1},fixable:"code",schema:[],messages:{preferToBeFalsy:"Prefer using toBeFalsy()"}},defaultOptions:[],create(b){return{CallExpression(Y){const q=parseVitestFnCall(Y,b);(q?.type==="expect"||q?.type==="expectTypeOf")&&q.args.length===1&&c$2(getFirstMatcherArg(q))&&EqualityMatcher.hasOwnProperty(getAccessorValue(q.matcher))&&b.report({node:q.matcher,messageId:"preferToBeFalsy",fix:$=>[$.replaceText(q.matcher,"toBeFalsy"),$.remove(q.args[0])]})}}}}),RULE_NAME$z="prefer-to-have-length",Er=createEslintRule({name:RULE_NAME$z,meta:{type:"suggestion",docs:{description:"enforce using toHaveLength()",recommended:!1},fixable:"code",messages:{preferToHaveLength:"Prefer toHaveLength()"},schema:[]},defaultOptions:[],create(b){return{CallExpression(Y){const q=parseVitestFnCall(Y,b);if(q?.type!=="expect")return;const{parent:$}=q.head.node;if($?.type!==utils.AST_NODE_TYPES.CallExpression)return;const[B]=$.arguments,{matcher:F}=q;!EqualityMatcher.hasOwnProperty(getAccessorValue(F))||B?.type!==utils.AST_NODE_TYPES.MemberExpression||!isSupportedAccessor(B.property,"length")||b.report({node:F,messageId:"preferToHaveLength",fix(W){return[W.removeRange([B.property.range[0]-1,B.range[1]]),W.replaceTextRange([F.parent.object.range[1],F.parent.range[1]],".toHaveLength")]}})}}}}),RULE_NAME$y="prefer-equality-matcher",fr=createEslintRule({name:RULE_NAME$y,meta:{type:"suggestion",docs:{description:"enforce using the built-in quality matchers",recommended:!1},messages:{useEqualityMatcher:"Prefer using one of the equality matchers instead",suggestEqualityMatcher:"Use `{{ equalityMatcher }}`"},hasSuggestions:!0,schema:[]},defaultOptions:[],create(b){return{CallExpression(Y){const q=parseVitestFnCall(Y,b);if(q?.type!=="expect"||q.args.length===0)return;const{parent:$}=q.head.node;if($?.type!==utils.AST_NODE_TYPES.CallExpression)return;const{arguments:[B],range:[,F]}=$,{matcher:W}=q,V=getFirstMatcherArg(q);if(B?.type!==utils.AST_NODE_TYPES.BinaryExpression||B.operator!=="==="&&B.operator!=="!=="||!EqualityMatcher.hasOwnProperty(getAccessorValue(W))||!isBooleanLiteral(V))return;const H=V.value,[X]=q.modifiers,z=q.modifiers.some(J=>getAccessorValue(J)==="not"),G=(B.operator==="!=="?!H:H)===z,ee=J=>se=>{const{sourceCode:Q}=b;let Z=X&&getAccessorValue(X)!=="not"?`.${getAccessorValue(X)}`:"";return G&&(Z+=`.${ModifierName.not}`),[se.replaceText(B,Q.getText(B.left)),se.replaceTextRange([F,W.parent.range[1]],`${Z}.${J}`),se.replaceText(V,Q.getText(B.right))]};b.report({messageId:"useEqualityMatcher",suggest:["toBe","toEqual","toStrictEqual"].map(J=>({messageId:"suggestEqualityMatcher",data:{equalityMatcher:J},fix:ee(J)})),node:W})}}}}),RULE_NAME$x="prefer-strict-equal",lr=createEslintRule({name:RULE_NAME$x,meta:{type:"suggestion",docs:{description:"enforce strict equal over equal",recommended:!1},messages:{useToStrictEqual:"Use `toStrictEqual()` instead",suggestReplaceWithStrictEqual:"Replace with `toStrictEqual()`"},schema:[],hasSuggestions:!0},defaultOptions:[],create(b){return{CallExpression(Y){const q=parseVitestFnCall(Y,b);if(q?.type!=="expect")return;const{matcher:$}=q;isSupportedAccessor($,"toEqual")&&b.report({messageId:"useToStrictEqual",node:$,suggest:[{messageId:"suggestReplaceWithStrictEqual",fix:B=>[replaceAccessorFixer(B,$,EqualityMatcher.toStrictEqual)]}]})}}}}),RULE_NAME$w="prefer-expect-resolves",Nr=createEslintRule({name:RULE_NAME$w,meta:{type:"suggestion",docs:{description:"enforce using `expect().resolves` over `expect(await ...)` syntax",recommended:!1},fixable:"code",messages:{expectResolves:"Use `expect().resolves` instead"},schema:[]},defaultOptions:[],create:b=>({CallExpression(Y){const q=parseVitestFnCall(Y,b);if(q?.type!=="expect")return;const{parent:$}=q.head.node;if($?.type!==utils.AST_NODE_TYPES.CallExpression)return;const[B]=$.arguments;B?.type===utils.AST_NODE_TYPES.AwaitExpression&&b.report({node:B,messageId:"expectResolves",fix(F){return[F.insertTextBefore($,"await "),F.removeRange([B.range[0],B.argument.range[0]]),F.insertTextAfter($,".resolves")]}})}})}),RULE_NAME$v="prefer-each",cr=createEslintRule({name:RULE_NAME$v,meta:{type:"suggestion",docs:{description:"enforce using `each` rather than manual loops",recommended:!1},schema:[],messages:{preferEach:"Prefer using `{{ fn }}.each` rather than a manual loop"}},defaultOptions:[],create(b){const Y=[];let q=!1;const $=()=>Y.length===1&&Y[0]==="test"?"it":"describe",B=()=>{Y.length===0||q||(Y.length=0)},F=W=>{Y.length===0||q||(b.report({node:W,messageId:"preferEach",data:{fn:$()}}),Y.length=0)};return{ForStatement:B,"ForStatement:exit":F,ForInStatement:B,"ForInStatement:exit":F,ForOfStatement:B,"ForOfStatement:exit":F,CallExpression(W){const{type:V}=parseVitestFnCall(W,b)??{};(V==="hook"||V==="describe"||V==="test")&&Y.push(V),V==="test"&&(q=!0)},"CallExpression:exit"(W){const{type:V}=parseVitestFnCall(W,b)??{};V==="test"&&(q=!1)}}}}),RULE_NAME$u="prefer-hooks-on-top",dr=createEslintRule({name:RULE_NAME$u,meta:{type:"suggestion",docs:{description:"enforce having hooks before any test cases",recommended:!1},messages:{noHookOnTop:"Hooks should come before test cases"},schema:[]},defaultOptions:[],create(b){const Y=[!1];return{CallExpression(q){isTypeOfVitestFnCall(q,b,["test"])&&(Y[Y.length-1]=!0),Y[Y.length-1]&&isTypeOfVitestFnCall(q,b,["hook"])&&b.report({messageId:"noHookOnTop",node:q}),Y.push(!1)},"CallExpression:exit"(){Y.pop()}}}}),RULE_NAME$t="prefer-hooks-in-order",a$4=["beforeAll","beforeEach","afterEach","afterAll"],Ar=createEslintRule({name:RULE_NAME$t,meta:{type:"suggestion",docs:{description:"enforce having hooks in consistent order",recommended:!1},messages:{reorderHooks:"`{{ currentHook }}` hooks should be before any `{{ previousHook }}` hooks"},schema:[]},defaultOptions:[],create(b){let Y=-1,q=!1;return{CallExpression($){if(q)return;const B=parseVitestFnCall($,b);if(B?.type!=="hook"){Y=-1;return}q=!0;const F=B.name,W=a$4.indexOf(F);if(W<Y){b.report({messageId:"reorderHooks",data:{previousHook:a$4[Y],currentHook:F},node:$}),q=!1;return}Y=W},"CallExpression:exit"($){if(isTypeOfVitestFnCall($,b,["hook"])){q=!1;return}q||(Y=-1)}}}}),RULE_NAME$s="prefer-mock-promise-shorthand",l$1=(b,Y)=>`${b}${Y?"Once":""}`,f$1=b=>b.body.type!==utils.AST_NODE_TYPES.BlockStatement?b.body:b.body.body[0]?.type===utils.AST_NODE_TYPES.ReturnStatement?b.body.body[0].argument:null,Mr=createEslintRule({name:RULE_NAME$s,meta:{type:"suggestion",docs:{description:"enforce mock resolved/rejected shorthands for promises",recommended:!1},messages:{useMockShorthand:"Prefer {{ replacement }}"},schema:[],fixable:"code"},defaultOptions:[],create(b){const Y=(q,$,B,F=B)=>{if(F?.type!==utils.AST_NODE_TYPES.CallExpression)return;const W=getNodeName(F);if(W!=="Promise.resolve"&&W!=="Promise.reject")return;const V=l$1(W.endsWith("reject")?"mockRejectedValue":"mockResolvedValue",$);b.report({node:q,messageId:"useMockShorthand",data:{replacement:V},fix(H){const{sourceCode:X}=b;return F.arguments.length>1?null:[H.replaceText(q,V),H.replaceText(B,F.arguments.length===1?X.getText(F.arguments[0]):"undefined")]}})};return{CallExpression(q){if(q.callee.type!==utils.AST_NODE_TYPES.MemberExpression||!isSupportedAccessor(q.callee.property)||q.arguments.length===0)return;const $=getAccessorValue(q.callee.property),B=$.endsWith("Once");if($===l$1("mockReturnValue",B))Y(q.callee.property,B,q.arguments[0]);else if($===l$1("mockImplementation",B)){const[F]=q.arguments;if(!isFunction(F)||F.params.length!==0)return;Y(q.callee.property,B,F,f$1(F))}}}}}),a$3=node_module.createRequire(typeof document>"u"?require("url").pathToFileURL(__filename).href:_documentCurrentScript&&_documentCurrentScript.tagName.toUpperCase()==="SCRIPT"&&_documentCurrentScript.src||new URL("index.cjs",document.baseURI).href),c$1=node_module.createRequire(a$3.resolve("eslint"));c$1.resolve("espree");const p=new Set([utils.AST_NODE_TYPES.Program,utils.AST_NODE_TYPES.BlockStatement,utils.AST_NODE_TYPES.SwitchCase,utils.AST_NODE_TYPES.SwitchStatement]),isValidParent=b=>p.has(b),isTokenASemicolon=b=>b.value===";"&&b.type===utils.AST_TOKEN_TYPES.Punctuator,getActualLastToken=(b,Y)=>{const q=b.getLastToken(Y),$=b.getTokenBefore(q),B=b.getTokenAfter(q);return $&&B&&$.range[0]>=Y.range[0]&&isTokenASemicolon(q)&&q.loc.start.line!==$.loc.end.line&&q.loc.end.line===B.loc.start.line?$:q},getPaddingLineSequences=(b,Y,q)=>{const $=[];let B=getActualLastToken(q,b);if(Y.loc.start.line-b.loc.end.line>=2)do{const F=q.getTokenAfter(B,{includeComments:!0});F.loc.start.line-B.loc.end.line>=2&&$.push([B,F]),B=F}while(B.range[0]<Y.range[0]);return $},areTokensOnSameLine=(b,Y)=>b.loc.end.line===Y.loc.start.line,E$1=b=>b.type===utils.AST_NODE_TYPES.TSAsExpression||b.type===utils.AST_NODE_TYPES.TSTypeAssertion,followTypeAssertionChain=b=>E$1(b)?followTypeAssertionChain(b.expression):b,RULE_NAME$r="prefer-vi-mocked",m$4=["Mock","MockedFunction","MockedClass","MockedObject"],wr=createEslintRule({name:RULE_NAME$r,meta:{type:"suggestion",docs:{description:"require `vi.mocked()` over `fn as Mock`",requiresTypeChecking:!0,recommended:!1},fixable:"code",messages:{useViMocked:"Prefer `vi.mocked()`"},schema:[]},defaultOptions:[],create(b){function Y(q){const{typeAnnotation:$}=q;if($.type!==utils.AST_NODE_TYPES.TSTypeReference)return;const{typeName:B}=$;if(B.type!==utils.AST_NODE_TYPES.Identifier||!m$4.includes(B.name))return;const F=b.sourceCode.text.slice(...followTypeAssertionChain(q.expression).range);b.report({node:q,messageId:"useViMocked",fix(W){return W.replaceText(q,`vi.mocked(${F})`)}})}return{TSAsExpression(q){q.parent.type!==utils.AST_NODE_TYPES.TSAsExpression&&Y(q)},TSTypeAssertion(q){Y(q)}}}}),RULE_NAME$q="prefer-snapshot-hint",E=["toMatchSnapshot","toThrowErrorMatchingSnapshot"],x$2=E,S$3=b=>{if(b.args.length===0)return!0;if(!isSupportedAccessor(b.matcher,"toMatchSnapshot"))return b.args.length!==1;if(b.args.length===2)return!1;const[Y]=b.args;return!isStringNode(Y)},Rr=createEslintRule({name:RULE_NAME$q,meta:{type:"suggestion",docs:{description:"enforce including a hint with external snapshots",recommended:!1},messages:{missingHint:"You should provide a hint for this snapshot"},schema:[{type:"string",enum:["always","multi"]}]},defaultOptions:["multi"],create(b,[Y]){const q=[];let $=0;const B=[],F=()=>{for(const H of q)S$3(H)&&b.report({messageId:"missingHint",node:H.matcher})},W=()=>{$++},V=()=>{$--,Y==="always"&&(F(),q.length=0),Y==="multi"&&$===0&&(q.length>1&&F(),q.length=0)};return{"Program:exit"(){W(),V()},FunctionExpression:W,"FunctionExpression:exit":V,ArrowFunctionExpression:W,"ArrowFunctionExpression:exit":V,"CallExpression:exit"(H){isTypeOfVitestFnCall(H,b,["describe","test"])&&($=B.pop()??0)},CallExpression(H){const X=parseVitestFnCall(H,b);if(X?.type!=="expect"){(X?.type==="describe"||X?.type==="test")&&(B.push($),$=0);return}const z=getAccessorValue(X.matcher);x$2.includes(z)&&q.push(X)}}}}),RULE_NAME$p="valid-describe-callback",o=b=>{const[Y]=b,q=b[b.length-1];return{start:Y.loc.start,end:q.loc.end}},i$1=(b,Y)=>b.members.every(q=>getAccessorValue(q)!=="each")&&Y.params.length,u$2=(b,Y)=>{b.body.forEach(q=>{q.type===utils.AST_NODE_TYPES.ReturnStatement&&Y.report({messageId:"unexpectedReturnInDescribe",node:q})})},Lr=createEslintRule({name:RULE_NAME$p,meta:{type:"problem",docs:{description:"enforce valid describe callback",recommended:!1},messages:{nameAndCallback:"Describe requires a name and callback arguments",secondArgumentMustBeFunction:"Second argument must be a function",unexpectedDescribeArgument:"Unexpected argument in describe callback",unexpectedReturnInDescribe:"Unexpected return statement in describe callback"},schema:[]},defaultOptions:[],create(b){return{CallExpression(Y){const q=parseVitestFnCall(Y,b);if(q?.type!=="describe"||q?.members[0]?.type===utils.AST_NODE_TYPES.Identifier&&q.members[0].name==="todo")return;if(Y.arguments.length<1)return b.report({messageId:"nameAndCallback",loc:Y.loc});const[,$,B]=Y.arguments;if(!$){b.report({messageId:"nameAndCallback",loc:o(Y.arguments)});return}if(!isFunction($)){if(B&&isFunction(B)){i$1(q,B)&&b.report({messageId:"unexpectedDescribeArgument",node:B}),B.body.type===utils.AST_NODE_TYPES.CallExpression&&b.report({messageId:"unexpectedReturnInDescribe",node:B}),B.body.type===utils.AST_NODE_TYPES.BlockStatement&&u$2(B.body,b);return}b.report({messageId:"secondArgumentMustBeFunction",loc:o(Y.arguments)});return}i$1(q,$)&&b.report({messageId:"unexpectedDescribeArgument",node:$}),$.body.type===utils.AST_NODE_TYPES.CallExpression&&b.report({messageId:"unexpectedReturnInDescribe",node:$}),$.body.type===utils.AST_NODE_TYPES.BlockStatement&&u$2($.body,b)}}}}),RULE_NAME$o="require-top-level-describe",ur=createEslintRule({name:RULE_NAME$o,meta:{docs:{description:"enforce that all tests are in a top-level describe",recommended:!1},messages:{tooManyDescribes:"There should not be more than {{ max }} describe{{ s }} at the top level",unexpectedTestCase:"All test cases must be wrapped in a describe block",unexpectedHook:"All hooks must be wrapped in a describe block"},type:"suggestion",schema:[{type:"object",properties:{maxNumberOfTopLevelDescribes:{type:"number",minimum:1}},additionalProperties:!1}]},defaultOptions:[{}],create(b){const{maxNumberOfTopLevelDescribes:Y=1/0}=b.options[0]??{};let q=0,$=0;return{CallExpression(B){const F=parseVitestFnCall(B,b);if(F){if(F.type==="describe"){$++,$===1&&(q++,q>Y&&b.report({node:B,messageId:"tooManyDescribes",data:{max:Y,s:Y===1?"":"s"}}));return}if($===0){if(F.type==="test"){b.report({node:B,messageId:"unexpectedTestCase"});return}F.type==="hook"&&b.report({node:B,messageId:"unexpectedHook"})}}},"CallExpression:exit"(B){isTypeOfVitestFnCall(B,b,["describe"])&&$--}}}}),RULE_NAME$n="require-to-throw-message",Tr=createEslintRule({name:RULE_NAME$n,meta:{type:"suggestion",docs:{description:"require toThrow() to be called with an error message",recommended:!1},schema:[],messages:{addErrorMessage:"Add an error message to {{ matcherName }}()"}},defaultOptions:[],create(b){return{CallExpression(Y){const q=parseVitestFnCall(Y,b);if(q?.type!=="expect")return;const{matcher:$}=q,B=getAccessorValue($);q.args.length===0&&["toThrow","toThrowError"].includes(B)&&!q.modifiers.some(F=>getAccessorValue(F)==="not")&&b.report({messageId:"addErrorMessage",data:{matcherName:B},node:$})}}}}),RULE_NAME$m="require-hook",S$2=(b,Y)=>parseVitestFnCall(b,Y)?!0:!!getNodeName(b)?.startsWith("vi"),m$3=b=>b.type===utils.AST_NODE_TYPES.Literal&&b.value===null||isIdentifier(b,"undefined"),a$2=(b,Y,q=[])=>{switch(b.type){case utils.AST_NODE_TYPES.ExpressionStatement:return a$2(b.expression,Y,q);case utils.AST_NODE_TYPES.CallExpression:return!(S$2(b,Y)||q.includes(getNodeName(b)));case utils.AST_NODE_TYPES.VariableDeclaration:return b.kind==="const"?!1:b.declarations.some(({init:$})=>$!==null&&!m$3($));default:return!1}},Ur=createEslintRule({name:RULE_NAME$m,meta:{docs:{description:"require setup and teardown to be within a hook",recommended:!1},messages:{useHook:"This should be done within a hook"},type:"suggestion",schema:[{type:"object",properties:{allowedFunctionCalls:{type:"array",items:{type:"string"}}},additionalProperties:!1}]},defaultOptions:[{allowedFunctionCalls:[]}],create(b){const{allowedFunctionCalls:Y}=b.options[0]??{},q=$=>{for(const B of $)a$2(B,b,Y)&&b.report({node:B,messageId:"useHook"})};return{Program($){q($.body)},CallExpression($){if(!isTypeOfVitestFnCall($,b,["describe"])||$.arguments.length<2)return;const[,B]=$.arguments;!isFunction(B)||B.body.type!==utils.AST_NODE_TYPES.BlockStatement||q(B.body.body)}}}}),RULE_NAME$l="require-local-test-context-for-concurrent-snapshots",_r=createEslintRule({name:RULE_NAME$l,meta:{docs:{description:"require local Test Context for concurrent snapshot tests",recommended:!1},messages:{requireLocalTestContext:"Use local Test Context instead"},type:"problem",schema:[]},defaultOptions:[],create(b){return{CallExpression(Y){const q=parseVitestFnCall(Y,b);q===null||q.type!=="expect"||q.type==="expect"&&q.head.type==="testContext"||!["toMatchSnapshot","toMatchInlineSnapshot","toMatchFileSnapshot","toThrowErrorMatchingSnapshot","toThrowErrorMatchingInlineSnapshot"].includes(Y.callee?.property.name)||!b.sourceCode.getAncestors(Y).some($=>$.type!==utils.AST_NODE_TYPES.CallExpression||!isTypeOfVitestFnCall($,b,["describe","test"])?!1:$.callee.type===utils.AST_NODE_TYPES.MemberExpression&&isSupportedAccessor($.callee.property,"concurrent"))||b.report({node:Y,messageId:"requireLocalTestContext"})}}}}),RULE_NAME$k="prefer-todo",S$1=b=>b.members.some(Y=>getAccessorValue(Y)!=="skip")||b.name.startsWith("x")?!1:!b.name.startsWith("f");function T$1(b){return isFunction(b)?b.body.type===utils.AST_NODE_TYPES.BlockStatement&&!b.body.body.length:!1}function a$1(b,Y){return b.members.length?replaceAccessorFixer(Y,b.members[0],"todo"):Y.replaceText(b.head.node,`${b.head.local}.todo`)}const br=createEslintRule({name:RULE_NAME$k,meta:{type:"layout",docs:{description:"enforce using `test.todo`",recommended:!1},messages:{emptyTest:"Prefer todo test case over empty test case",unimplementedTest:"Prefer todo test case over unimplemented test case"},fixable:"code",schema:[]},defaultOptions:[],create(b){return{CallExpression(Y){const[q,$]=Y.arguments,B=parseVitestFnCall(Y,b);!q||B?.type!=="test"||!S$1(B)||!isStringNode(q)||($&&T$1($)&&b.report({messageId:"emptyTest",node:Y,fix:F=>[F.removeRange([q.range[1],$.range[1]]),a$1(B,F)]}),hasOnlyOneArgument(Y)&&b.report({messageId:"unimplementedTest",node:Y,fix:F=>a$1(B,F)}))}}}}),RULE_NAME$j="prefer-spy-on",u$1=b=>"object"in b?b.object:b.callee.type===utils.AST_NODE_TYPES.MemberExpression?b.callee.object:null,a=b=>{if(b.type!==utils.AST_NODE_TYPES.CallExpression&&b.type!==utils.AST_NODE_TYPES.MemberExpression)return null;const Y=u$1(b);return Y?Y.type===utils.AST_NODE_TYPES.Identifier?b.type===utils.AST_NODE_TYPES.CallExpression&&getNodeName(b.callee)==="vi.fn"?b:null:a(Y):null},S=(b,Y)=>{if(b.parent?.type===utils.AST_NODE_TYPES.MemberExpression&&b.parent.property.type===utils.AST_NODE_TYPES.Identifier&&b.parent.property.name==="mockImplementation")return"";const[q]=b.arguments,$=q&&Y.sourceCode.getText(q);return $?`.mockImplementation(${$})`:".mockImplementation()"},hr=createEslintRule({name:RULE_NAME$j,meta:{type:"suggestion",docs:{description:"enforce using `vi.spyOn`",recommended:!1},messages:{useViSpayOn:"Use `vi.spyOn` instead"},fixable:"code",schema:[]},defaultOptions:[],create(b){return{AssignmentExpression(Y){const{left:q,right:$}=Y;if(q.type!==utils.AST_NODE_TYPES.MemberExpression)return;const B=a($);B&&b.report({node:Y,messageId:"useViSpayOn",fix(F){const W=q.property.type===utils.AST_NODE_TYPES.Identifier&&!q.computed?"'":"",V=S(B,b);return[F.insertTextBefore(q,"vi.spyOn("),F.replaceTextRange([q.object.range[1],q.property.range[0]],`, ${W}`),F.replaceTextRange([q.property.range[1],B.range[1]],`${W})${V}`)]}})}}}}),RULE_NAME$i="prefer-comparison-matcher",g$1=b=>isStringNode(b)||b?.type===utils.AST_NODE_TYPES.TemplateLiteral,C=b=>g$1(b.left)||g$1(b.right),M$1=b=>{switch(b){case">":return"<=";case"<":return">=";case">=":return"<";case"<=":return">"}return null},O=(b,Y)=>{switch(Y?M$1(b):b){case">":return"toBeGreaterThan";case"<":return"toBeLessThan";case">=":return"toBeGreaterThanOrEqual";case"<=":return"toBeLessThanOrEqual"}return null},gr=createEslintRule({name:RULE_NAME$i,meta:{type:"suggestion",docs:{description:"enforce using the built-in comparison matchers",recommended:!1},schema:[],fixable:"code",messages:{useToBeComparison:"Prefer using `{{ preferredMatcher }}` instead"}},defaultOptions:[],create(b){return{CallExpression(Y){const q=parseVitestFnCall(Y,b);if(q?.type!=="expect"||q.args.length===0)return;const{parent:$}=q.head.node;if($?.type!==utils.AST_NODE_TYPES.CallExpression)return;const{arguments:[B],range:[,F]}=$,{matcher:W}=q,V=getFirstMatcherArg(q);if(B?.type!==utils.AST_NODE_TYPES.BinaryExpression||C(B)||!EqualityMatcher.hasOwnProperty(getAccessorValue(W))||!isBooleanLiteral(V))return;const[H]=q.modifiers,X=q.modifiers.some(G=>getAccessorValue(G)==="not"),z=O(B.operator,V.value===X);z&&b.report({fix(G){const{sourceCode:ee}=b,J=H&&getAccessorValue(H)!=="not"?`.${getAccessorValue(H)}`:"";return[G.replaceText(B,ee.getText(B.left)),G.replaceTextRange([F,W.parent.range[1]],`${J}.${z}`),G.replaceText(V,ee.getText(B.right))]},messageId:"useToBeComparison",data:{preferredMatcher:z},node:W})}}}}),RULE_NAME$h="prefer-describe-function-title",kr=createEslintRule({name:RULE_NAME$h,meta:{type:"problem",docs:{description:"enforce using a function as a describe title over an equivalent string",recommended:!1},fixable:"code",schema:[],messages:{preferFunction:"Enforce using a function over an equivalent string"}},defaultOptions:[],create(b){return{CallExpression(Y){if(Y.arguments.length<2)return;const q=getModuleScope(b,Y),[$]=Y.arguments;if($.type===utils.AST_NODE_TYPES.MemberExpression&&$.object.type===utils.AST_NODE_TYPES.Identifier&&$.property.type===utils.AST_NODE_TYPES.Identifier){const W=$.object.name;if(q?.set.get(W)?.defs[0]?.type!==scopeManager.DefinitionType.ImportBinding||$.property.name!=="name")return;b.report({node:$,messageId:"preferFunction",fix(V){return V.replaceText($,W)}});return}if($.type!==utils.AST_NODE_TYPES.Literal||typeof $.value!="string")return;const B=$.value;if(parseVitestFnCall(Y,b)?.type!=="describe")return;const F=q?.set.get(B)?.defs[0];if(F?.type===scopeManager.DefinitionType.ImportBinding){if(parsePluginSettings(b.settings).typecheck){const W=utils.ESLintUtils.getParserServices(b).getTypeAtLocation(F.node);if(!isClassOrFunctionType(W))return}b.report({node:$,messageId:"preferFunction",fix(W){return W.replaceText($,B)}})}}}}}),RULE_NAME$g="prefer-to-contain",T=b=>b.type===utils.AST_NODE_TYPES.CallExpression&&b.callee.type===utils.AST_NODE_TYPES.MemberExpression&&isSupportedAccessor(b.callee.property,"includes")&&hasOnlyOneArgument(b)&&b.arguments[0].type!==utils.AST_NODE_TYPES.SpreadElement,xr=createEslintRule({name:RULE_NAME$g,meta:{docs:{description:"enforce using toContain()",recommended:!1},messages:{useToContain:"Use toContain() instead"},fixable:"code",type:"suggestion",schema:[]},defaultOptions:[],create(b){return{CallExpression(Y){const q=parseVitestFnCall(Y,b);if(q?.type!=="expect"||q.args.length===0)return;const{parent:$}=q.head.node;if($?.type!==utils.AST_NODE_TYPES.CallExpression)return;const{arguments:[B],range:[,F]}=$,{matcher:W}=q,V=getFirstMatcherArg(q);if(!B||V.type===utils.AST_NODE_TYPES.SpreadElement||!EqualityMatcher.hasOwnProperty(getAccessorValue(W))||!isBooleanLiteral(V)||!T(B))return;const H=q.modifiers.some(X=>getAccessorValue(X)==="not");b.report({fix(X){const{sourceCode:z}=b,G=V.value===H;return[X.removeRange([B.callee.property.range[0]-1,B.range[1]]),X.replaceTextRange([F,W.parent.range[1]],G?`.${ModifierName.not}.toContain`:".toContain"),X.replaceText(q.args[0],z.getText(B.arguments[0]))]},messageId:"useToContain",node:W})}}}}),RULE_NAME$f="prefer-expect-assertions",L=b=>{let Y=b;for(;Y;){if(Y.parent?.type===utils.AST_NODE_TYPES.BlockStatement)return Y.parent.body[0]===Y;if(Y.parent?.type===utils.AST_NODE_TYPES.ArrowFunctionExpression)return!0;Y=Y.parent}throw new Error("Could not find parent block statement")},y$2=(b,Y,q)=>({messageId:"suggestRemovingExtraArguments",fix:$=>removeExtraArgumentsFixer($,b,Y,q)}),Cr=createEslintRule({name:"prefer-expect-assertions",meta:{docs:{description:"enforce using expect assertions instead of callbacks",recommended:!1},messages:{hasAssertionsTakesNoArguments:"`expect.hasAssertions` expects no arguments",assertionsRequiresOneArgument:"`expect.assertions` excepts a single argument of type number",assertionsRequiresNumberArgument:"This argument should be a number",haveExpectAssertions:"Every test should have either `expect.assertions(<number of assertions>)` or `expect.hasAssertions()` as its first expression",suggestAddingHasAssertions:"Add `expect.hasAssertions()`",suggestAddingAssertions:"Add `expect.assertions(<number of assertions>)`",suggestRemovingExtraArguments:"Remove extra arguments"},type:"suggestion",hasSuggestions:!0,schema:[{type:"object",properties:{onlyFunctionsWithAsyncKeyword:{type:"boolean"},onlyFunctionsWithExpectInLoop:{type:"boolean"},onlyFunctionsWithExpectInCallback:{type:"boolean"}},additionalProperties:!1}]},defaultOptions:[{onlyFunctionsWithAsyncKeyword:!1,onlyFunctionsWithExpectInCallback:!1,onlyFunctionsWithExpectInLoop:!1}],create(b,[Y]){let q=0,$=!1,B=!1,F=!1,W=null,V=!1,H=!1;const X=Q=>!!(!Y.onlyFunctionsWithAsyncKeyword&&!Y.onlyFunctionsWithExpectInCallback&&!Y.onlyFunctionsWithExpectInLoop||Y.onlyFunctionsWithAsyncKeyword&&Q.async||Y.onlyFunctionsWithExpectInCallback&&$||Y.onlyFunctionsWithExpectInLoop&&B);function z(Q,Z){if(getAccessorValue(Q.members[0])==="hasAssertions"){Q.args.length&&b.report({messageId:"hasAssertionsTakesNoArguments",node:Q.matcher,suggest:[y$2(b,Z,0)]});return}if(Q.args.length!==1){let{loc:ne}=Q.matcher;const te=[];Q.args.length&&(ne=Q.args[1].loc,te.push(y$2(b,Z,1))),b.report({messageId:"assertionsRequiresOneArgument",suggest:te,loc:ne});return}const[oe]=Q.args;oe.type===utils.AST_NODE_TYPES.Literal&&typeof oe.value=="number"&&Number.isInteger(oe.value)||b.report({messageId:"assertionsRequiresNumberArgument",node:oe})}const G=()=>V&&q++,ee=()=>V&&q--,J=()=>H=!0,se=()=>H=!1;return{FunctionExpression:G,"FunctionExpression:exit":ee,ArrowFunctionExpression:G,"ArrowFunctionExpression:exit":ee,ForStatement:J,"ForStatement:exit":se,ForInStatement:J,"ForInStatement:exit":se,ForOfStatement:J,"ForOfStatement:exit":se,CallExpression(Q){const Z=parseVitestFnCall(Q,b);if(Z?.type==="test"){V=!0;return}Z?.head.type==="testContext"&&Z.members[0]&&Z.members[0].type===utils.AST_NODE_TYPES.Identifier&&Z.members[0].name==="expect"&&(W=`${Z.head.local}`),Z?.type==="expect"&&V&&(q===1&&L(Q)&&Z.head.node.parent?.type===utils.AST_NODE_TYPES.MemberExpression&&Z.members.length===1&&["assertions","hasAssertions"].includes(getAccessorValue(Z.members[0]))&&(z(Z,Q),F=!0),H&&(B=!0),q>1&&($=!0))},"CallExpression:exit"(Q){if(!isTypeOfVitestFnCall(Q,b,["test"])||(V=!1,Q.arguments.length<2))return;const[,Z]=Q.arguments;if(!isFunction(Z)||!X(Z))return;if(B=!1,$=!1,F){F=!1;return}const oe=[];if(Z.body.type===utils.AST_NODE_TYPES.BlockStatement){const ne=W?`${W}.`:"";oe.push(["suggestAddingHasAssertions",`${ne}expect.hasAssertions();`],["suggestAddingAssertions",`${ne}expect.assertions();`])}b.report({messageId:"haveExpectAssertions",node:Q,suggest:oe.map(([ne,te])=>({messageId:ne,fix:re=>re.insertTextBeforeRange([Z.body.range[0]+1,Z.body.range[1]],te)}))})}}}});var PaddingType=(b=>(b[b.Any=0]="Any",b[b.Always=1]="Always",b))(PaddingType||{}),StatementType=(b=>(b[b.Any=0]="Any",b[b.AfterAllToken=1]="AfterAllToken",b[b.AfterEachToken=2]="AfterEachToken",b[b.BeforeAllToken=3]="BeforeAllToken",b[b.BeforeEachToken=4]="BeforeEachToken",b[b.DescribeToken=5]="DescribeToken",b[b.ExpectToken=6]="ExpectToken",b[b.ExpectTypeOfToken=7]="ExpectTypeOfToken",b[b.FdescribeToken=8]="FdescribeToken",b[b.FitToken=9]="FitToken",b[b.ItToken=10]="ItToken",b[b.TestToken=11]="TestToken",b[b.XdescribeToken=12]="XdescribeToken",b[b.XitToken=13]="XitToken",b[b.XtestToken=14]="XtestToken",b))(StatementType||{});const x$1=(b,Y,q)=>{const{sourceCode:$,ruleContext:B}=q;getPaddingLineSequences(b,Y,$).length>0||B.report({node:Y,messageId:"missingPadding",fix(F){let W=getActualLastToken($,b);const V=$.getFirstTokenBetween(W,Y,{includeComments:!0,filter(X){return areTokensOnSameLine(W,X)?(W=X,!1):!0}})||Y,H=areTokensOnSameLine(W,V)?`

`:`
`;return F.insertTextAfter(W,H)}})},m$2={0:()=>!0,1:x$1},y$1=()=>{let b=null;return{get prevNode(){return b.prevNode},set prevNode(Y){b.prevNode=Y},enter(){b={upper:b,prevNode:null}},exit(){b=b.upper}}},i=b=>(Y,q)=>{let $=Y;if($.type===utils.AST_NODE_TYPES.ExpressionStatement){$.expression.type===utils.AST_NODE_TYPES.AwaitExpression&&($=$.expression.argument);const B=q.getFirstToken($);return B?.type===utils.AST_TOKEN_TYPES.Identifier&&B.value===b}return!1},A={0:()=>!0,1:i("afterAll"),2:i("afterEach"),3:i("beforeAll"),4:i("beforeEach"),5:i("describe"),6:i("expect"),7:i("expectTypeOf"),8:i("fdescribe"),9:i("fit"),10:i("it"),11:i("test"),12:i("xdescribe"),13:i("xit"),14:i("xtest")},l=(b,Y,q)=>{let $=b;const{sourceCode:B}=q;for(;$.type===utils.AST_NODE_TYPES.LabeledStatement;)$=$.body;return Array.isArray(Y)?Y.some(F=>l($,F,q)):A[Y]($,B)},N$1=(b,Y,q)=>{const{configs:$}=q,B=F=>m$2[F](b,Y,q);for(let F=$.length-1;F>=0;--F){const{prevStatementType:W,nextStatementType:V,paddingType:H}=$[F];if(l(b,W,q)&&l(Y,V,q))return B(H)}return B(0)},u=(b,Y)=>{const{scopeInfo:q}=Y;isValidParent(b?.parent.type)&&(q.prevNode&&N$1(q.prevNode,b,Y),q.prevNode=b)},createPaddingRule=(b,Y,q,$=!1)=>createEslintRule({name:b,meta:{docs:{description:Y},fixable:"whitespace",deprecated:$,messages:{missingPadding:"expect blank line before this statement"},schema:[],type:"suggestion"},defaultOptions:[],create(B){const F={ruleContext:B,sourceCode:B.sourceCode??B.getSourceCode(),scopeInfo:y$1(),configs:q},{scopeInfo:W}=F;return{Program:W.enter,"Program:exit":W.exit,BlockStatement:W.enter,"BlockStatement:exit":W.exit,SwitchStatement:W.enter,"SwitchStatement:exit":W.exit,":statement":V=>u(V,F),SwitchCase(V){u(V,F),W.enter()},"SwitchCase:exit":W.exit}}}),RULE_NAME$e="padding-around-after-all-blocks",config$6=[{paddingType:PaddingType.Always,prevStatementType:StatementType.Any,nextStatementType:StatementType.AfterAllToken},{paddingType:PaddingType.Always,prevStatementType:StatementType.AfterAllToken,nextStatementType:StatementType.Any}],vr=createPaddingRule(RULE_NAME$e,"Enforce padding around `afterAll` blocks",config$6),RULE_NAME$d="padding-around-after-each-blocks",config$5=[{paddingType:PaddingType.Always,prevStatementType:StatementType.Any,nextStatementType:StatementType.AfterEachToken},{paddingType:PaddingType.Always,prevStatementType:StatementType.AfterEachToken,nextStatementType:StatementType.Any}],Br=createPaddingRule(RULE_NAME$d,"Enforce padding around `afterEach` blocks",config$5),RULE_NAME$c="padding-around-before-all-blocks",config$4=[{paddingType:PaddingType.Always,prevStatementType:StatementType.Any,nextStatementType:StatementType.BeforeAllToken},{paddingType:PaddingType.Always,prevStatementType:StatementType.BeforeAllToken,nextStatementType:StatementType.Any}],Ir=createPaddingRule(RULE_NAME$c,"Enforce padding around `beforeAll` blocks",config$4),RULE_NAME$b="padding-around-before-each-blocks",config$3=[{paddingType:PaddingType.Always,prevStatementType:StatementType.Any,nextStatementType:StatementType.BeforeEachToken},{paddingType:PaddingType.Always,prevStatementType:StatementType.BeforeEachToken,nextStatementType:StatementType.Any}],Sr=createPaddingRule(RULE_NAME$b,"Enforce padding around `beforeEach` blocks",config$3),RULE_NAME$a="padding-around-describe-blocks",config$2=[{paddingType:PaddingType.Always,prevStatementType:StatementType.Any,nextStatementType:[StatementType.DescribeToken,StatementType.FdescribeToken,StatementType.XdescribeToken]},{paddingType:PaddingType.Always,prevStatementType:[StatementType.DescribeToken,StatementType.FdescribeToken,StatementType.XdescribeToken],nextStatementType:StatementType.Any}],Or=createPaddingRule(RULE_NAME$a,"Enforce padding around `describe` blocks",config$2),RULE_NAME$9="padding-around-expect-groups",config$1=[{paddingType:PaddingType.Always,prevStatementType:StatementType.Any,nextStatementType:StatementType.ExpectToken},{paddingType:PaddingType.Always,prevStatementType:StatementType.ExpectToken,nextStatementType:StatementType.Any},{paddingType:PaddingType.Any,prevStatementType:StatementType.ExpectToken,nextStatementType:StatementType.ExpectToken},{paddingType:PaddingType.Always,prevStatementType:StatementType.Any,nextStatementType:StatementType.ExpectTypeOfToken},{paddingType:PaddingType.Always,prevStatementType:StatementType.ExpectTypeOfToken,nextStatementType:StatementType.Any},{paddingType:PaddingType.Any,prevStatementType:StatementType.ExpectTypeOfToken,nextStatementType:StatementType.ExpectTypeOfToken}],Dr=createPaddingRule(RULE_NAME$9,"Enforce padding around `expect` groups",config$1),RULE_NAME$8="padding-around-test-blocks",config=[{paddingType:PaddingType.Always,prevStatementType:StatementType.Any,nextStatementType:[StatementType.TestToken,StatementType.ItToken,StatementType.FitToken,StatementType.XitToken,StatementType.XtestToken]},{paddingType:PaddingType.Always,prevStatementType:[StatementType.TestToken,StatementType.ItToken,StatementType.FitToken,StatementType.XitToken,StatementType.XtestToken],nextStatementType:StatementType.Any}],Hr=createPaddingRule(RULE_NAME$8,"Enforce padding around `test` blocks",config),RULE_NAME$7="padding-around-all",yr=createPaddingRule(RULE_NAME$7,"Enforce padding around vitest functions",[...config$6,...config$5,...config$4,...config$3,...config$2,...config$1,...config]),RULE_NAME$6="valid-expect-in-promise",w=["toRejectWith","toResolveWith"],c=b=>{if(b.type===utils.AST_NODE_TYPES.CallExpression&&b.callee.type===utils.AST_NODE_TYPES.MemberExpression&&isSupportedAccessor(b.callee.property)){if(b.arguments.length===0)return!1;switch(getAccessorValue(b.callee.property)){case"then":return b.arguments.length<3;case"catch":case"finally":return b.arguments.length<2}}return!1},k=(b,Y)=>{const q=parseVitestFnCall(b,Y);if(q?.type!=="test")return!1;const $=q.members.some(W=>getAccessorValue(W)==="each");if($&&b.callee.type!==utils.AST_NODE_TYPES.TaggedTemplateExpression)return!0;const[,B]=b.arguments,F=Number($);return B&&isFunction(B)&&B.params.length===1+F},x=(b,Y)=>{const{name:q}=Y;if(b.argument===null)return!1;if(b.argument.type===utils.AST_NODE_TYPES.CallExpression&&b.argument.arguments.length>0){const $=getNodeName(b.argument);if(["Promise.all","Promise.allSettled"].includes($)){const[B]=b.argument.arguments;if(B.type===utils.AST_NODE_TYPES.ArrayExpression&&B.elements.some(F=>F&&isIdentifier(F,q)))return!0}if(["Promise.resolve","Promise.reject"].includes($)&&b.argument.arguments.length===1)return isIdentifier(b.argument.arguments[0],q)}return isIdentifier(b.argument,q)},h=(b,Y)=>{for(const q of Y)if(q?.type===utils.AST_NODE_TYPES.AwaitExpression&&isIdentifier(q.argument,b)||q?.type===utils.AST_NODE_TYPES.ArrayExpression&&h(b,q.elements))return!0;return!1},M=(b,Y)=>{let q=Y;for(;q;){if(q.type===utils.AST_NODE_TYPES.CallExpression){if(h(b,q.arguments))return!0;q=q.callee}if(q.type!==utils.AST_NODE_TYPES.MemberExpression)break;q=q.object}return!1},N=b=>{let Y=b,q=b;for(;q&&(q.type===utils.AST_NODE_TYPES.CallExpression&&(Y=q,q=q.callee),q.type===utils.AST_NODE_TYPES.MemberExpression);)q=q.object;return Y},m$1=(b,Y,q)=>{const{name:$}=b;for(const B of Y)if(!(B.range[0]<=b.range[0])){if(B.type===utils.AST_NODE_TYPES.ReturnStatement)return x(B,b);if(B.type===utils.AST_NODE_TYPES.ExpressionStatement){if(B.expression.type===utils.AST_NODE_TYPES.CallExpression){if(M($,B.expression))return!0;const F=N(B.expression),W=parseVitestFnCall(B.expression,q);if(W?.type==="expect"&&F.arguments.length>0&&isIdentifier(F.arguments[0],$)&&W.members.some(V=>{const H=getAccessorValue(V);return H===ModifierName.resolves||H===ModifierName.rejects}))return!0}if(B.expression.type===utils.AST_NODE_TYPES.AwaitExpression&&x(B.expression,b))return!0;if(B.expression.type===utils.AST_NODE_TYPES.AssignmentExpression){if(isIdentifier(B.expression.left,$)&&getNodeName(B.expression.right)?.startsWith(`${$}.`)&&c(B.expression.right))continue;break}}if(B.type===utils.AST_NODE_TYPES.BlockStatement&&m$1(b,B.body,q))return!0}return!1},y=b=>{let Y=b;for(;Y;){if(Y.type===utils.AST_NODE_TYPES.BlockStatement)return Y.body;Y=Y.parent}throw new Error("Could not find BlockStatement - please file a github issue at https://github.com/vitest-dev/eslint-plugin-vitest")},I=(b,Y)=>{let q=b;for(;q;){if(isFunction(q))return q=q.parent,q?.type===utils.AST_NODE_TYPES.CallExpression&&isTypeOfVitestFnCall(q,Y,["test"]);q=q.parent}return!1},P=(b,Y)=>{const q=y(b);return isIdentifier(b.id)?m$1(b.id,q,Y):!0},qr=createEslintRule({name:RULE_NAME$6,meta:{docs:{description:"require promises that have expectations in their chain to be valid"},messages:{expectInFloatingPromise:"This promise should either be returned or awaited to ensure the expects in its chain are called"},type:"suggestion",schema:[]},defaultOptions:[{alwaysAwait:!1,asyncMatchers:w,minArgs:1,maxArgs:1}],create(b){let Y=!1;const q=[];return{CallExpression($){if(k($,b)){Y=!0;return}if(c($)){q.unshift(!1);return}q.length>0&&isTypeOfVitestFnCall($,b,["expect"])&&(q[0]=!0)},"CallExpression:exit"($){if(Y){isTypeOfVitestFnCall($,b,["test"])&&(Y=!1);return}if(!c($)||!q.shift())return;const{parent:B}=findTopMostCallExpression($);if(!(!B||!I(B,b))){switch(B.type){case utils.AST_NODE_TYPES.VariableDeclarator:{if(P(B,b))return;break}case utils.AST_NODE_TYPES.AssignmentExpression:{if(B.left.type===utils.AST_NODE_TYPES.Identifier&&m$1(B.left,y(B),b))return;break}case utils.AST_NODE_TYPES.ExpressionStatement:break;case utils.AST_NODE_TYPES.ReturnStatement:case utils.AST_NODE_TYPES.AwaitExpression:default:return}b.report({messageId:"expectInFloatingPromise",node:B})}}}}}),RULE_NAME$5="prefer-strict-boolean-matchers",Fr=createEslintRule({name:RULE_NAME$5,meta:{type:"suggestion",docs:{description:"enforce using `toBe(true)` and `toBe(false)` over matchers that coerce types to boolean",recommended:!1},messages:{preferToBeTrue:"Prefer using `toBe(true)` to test value is `true`",preferToBeFalse:"Prefer using `toBe(false)` to test value is `false`"},fixable:"code",schema:[]},defaultOptions:[],create(b){return{CallExpression(Y){const q=parseVitestFnCall(Y,b);if(!(q?.type==="expect"||q?.type==="expectTypeOf"))return;const $=getAccessorValue(q.matcher);$==="toBeFalsy"&&b.report({node:q.matcher,messageId:"preferToBeFalse",fix:B=>[B.replaceText(q.matcher,"toBe"),B.insertTextAfterRange([q.matcher.range[0],q.matcher.range[1]+1],"false")]}),$==="toBeTruthy"&&b.report({node:q.matcher,messageId:"preferToBeTrue",fix:B=>[B.replaceText(q.matcher,"toBe"),B.insertTextAfterRange([q.matcher.range[0],q.matcher.range[1]+1],"true")]})}}}}),RULE_NAME$4="require-mock-type-parameters",Vr=createEslintRule({name:RULE_NAME$4,meta:{type:"suggestion",docs:{description:"enforce using type parameters with vitest mock functions",recommended:!1},messages:{noTypeParameter:"Missing type parameters"},fixable:"code",schema:[{type:"object",properties:{checkImportFunctions:{type:"boolean"}},additionalProperties:!1}]},defaultOptions:[{checkImportFunctions:!1}],create(b,[Y]){return{CallExpression(q){const $=parseVitestFnCall(q,b);if($?.type==="vi")for(const B of $?.members)!("name"in B)||B.parent.parent.typeArguments!==void 0||(B.name==="fn"&&b.report({node:B,messageId:"noTypeParameter"}),Y.checkImportFunctions&&["importActual","importMock"].includes(B.name)&&b.report({node:B,messageId:"noTypeParameter"}))}}}}),RULE_NAME$3="prefer-called-once",m=b=>b.type===utils.AST_NODE_TYPES.Literal&&b.value===1,Pr=createEslintRule({name:RULE_NAME$3,meta:{docs:{description:"enforce using `toBeCalledOnce()` or `toHaveBeenCalledOnce()`",recommended:!1},messages:{preferCalledOnce:"Prefer {{ replacedMatcherName }}()"},type:"suggestion",fixable:"code",schema:[]},defaultOptions:[],create(b){return{CallExpression(Y){const q=parseVitestFnCall(Y,b);if(q?.type!=="expect")return;const{matcher:$}=q,B=getAccessorValue($);if(["toBeCalledTimes","toHaveBeenCalledTimes"].includes(B)&&q.args.length===1&&m(getFirstMatcherArg(q))){const F=B.replace("Times","Once");b.report({data:{replacedMatcherName:F},messageId:"preferCalledOnce",node:$,fix:W=>[W.replaceText($,F),W.remove(q.args[0])]})}}}}}),RULE_NAME$2="prefer-called-times",Gr=createEslintRule({name:RULE_NAME$2,meta:{docs:{description:"enforce using `toBeCalledTimes(1)` or `toHaveBeenCalledTimes(1)`",recommended:!1},messages:{preferCalledTimes:"Prefer {{ replacedMatcherName }}(1)"},type:"suggestion",fixable:"code",schema:[]},defaultOptions:[],create(b){return{CallExpression(Y){const q=parseVitestFnCall(Y,b);if(q?.type!=="expect")return;const{matcher:$}=q,B=getAccessorValue($);if(["toBeCalledOnce","toHaveBeenCalledOnce"].includes(B)){const F=B.replace("Once","Times");b.report({data:{replacedMatcherName:F},messageId:"preferCalledTimes",node:$,fix:W=>[W.replaceText($,F),W.insertTextAfterRange([q.matcher.range[0],q.matcher.range[1]+1],"1")]})}}}}}),RULE_NAME$1="prefer-expect-type-of",g={string:"toBeString",number:"toBeNumber",boolean:"toBeBoolean",object:"toBeObject",function:"toBeFunction",symbol:"toBeSymbol",bigint:"toBeBigInt",undefined:"toBeUndefined"},jr=createEslintRule({name:RULE_NAME$1,meta:{type:"suggestion",docs:{description:"enforce using `expectTypeOf` instead of `expect(typeof ...)`",recommended:!1},schema:[],fixable:"code",messages:{preferExpectTypeOf:'Use `expectTypeOf({{ value }}).{{ matcher }}()` instead of `expect(typeof {{ value }}).toBe("{{ type }}")`'}},defaultOptions:[],create(b){return{CallExpression(Y){const q=parseVitestFnCall(Y,b);if(q?.type!=="expect"||q.head.node.parent?.type!==utils.AST_NODE_TYPES.CallExpression)return;const $=q.head.node.parent,[B]=$.arguments;if(!B||B.type!==utils.AST_NODE_TYPES.UnaryExpression||B.operator!=="typeof")return;const F=getAccessorValue(q.matcher);if(F!=="toBe"&&F!=="toEqual")return;const[W]=q.args;if(!W||W.type!==utils.AST_NODE_TYPES.Literal||typeof W.value!="string")return;const V=W.value,H=g[V];if(!H)return;const X=b.sourceCode.getText(B.argument),z=q.modifiers.map(ee=>getAccessorValue(ee)).join("."),G=z?`.${z}`:"";b.report({node:Y,messageId:"preferExpectTypeOf",data:{value:X,matcher:H,type:V},fix(ee){return ee.replaceText(Y,`expectTypeOf(${X})${G}.${H}()`)}})}}}}),RULE_NAME="warn-todo",Kr=createEslintRule({name:RULE_NAME,meta:{docs:{description:"disallow `.todo` usage",recommended:!1},messages:{warnTodo:"The use of `.todo` is not recommended."},type:"suggestion",schema:[]},defaultOptions:[],create(b){return{CallExpression(Y){const q=parseVitestFnCall(Y,b);if(q?.type!=="describe"&&q?.type!=="test"&&q?.type!=="it")return;const $=q.members.find(B=>B.type==="Identifier"&&B.name==="todo");$&&b.report({messageId:"warnTodo",node:$})}}}}),Te=b=>Object.keys(b).reduce((Y,q)=>({...Y,[`vitest/${q}`]:b[q]}),{}),Ue=b=>({plugins:["@vitest"],rules:Object.keys(b).reduce((Y,q)=>({...Y,[`@vitest/${q}`]:b[q]}),{})}),_e={[RULE_NAME$18]:"warn",[RULE_NAME$17]:"warn",[RULE_NAME$15]:"warn",[RULE_NAME$14]:"warn",[RULE_NAME$11]:"warn",[RULE_NAME$10]:"warn",[RULE_NAME$_]:"warn",[RULE_NAME$Z]:"warn",[RULE_NAME$Y]:"warn",[RULE_NAME$X]:"warn",[RULE_NAME$W]:"warn",[RULE_NAME$U]:"warn",[RULE_NAME$Q]:"warn",[RULE_NAME$P]:"warn",[RULE_NAME$O]:"warn",[RULE_NAME$N]:"warn",[RULE_NAME$M]:"warn",[RULE_NAME$L]:"warn",[RULE_NAME$K]:"warn",[RULE_NAME$J]:"warn",[RULE_NAME$I]:"warn",[RULE_NAME$H]:"warn",[RULE_NAME$G]:"warn",[RULE_NAME$F]:"warn",[RULE_NAME$A]:"off",[RULE_NAME$C]:"warn",[RULE_NAME$B]:"off",[RULE_NAME$z]:"warn",[RULE_NAME$y]:"warn",[RULE_NAME$x]:"warn",[RULE_NAME$w]:"warn",[RULE_NAME$v]:"warn",[RULE_NAME$u]:"warn",[RULE_NAME$t]:"warn",[RULE_NAME$s]:"warn",[RULE_NAME$r]:"warn",[RULE_NAME$q]:"warn",[RULE_NAME$o]:"warn",[RULE_NAME$n]:"warn",[RULE_NAME$m]:"warn",[RULE_NAME$k]:"warn",[RULE_NAME$j]:"warn",[RULE_NAME$i]:"warn",[RULE_NAME$h]:"warn",[RULE_NAME$g]:"warn",[RULE_NAME$f]:"warn",[RULE_NAME$$]:"warn",[RULE_NAME$e]:"warn",[RULE_NAME$d]:"warn",[RULE_NAME$7]:"warn",[RULE_NAME$c]:"warn",[RULE_NAME$b]:"warn",[RULE_NAME$a]:"warn",[RULE_NAME$9]:"warn",[RULE_NAME$8]:"warn",[RULE_NAME$6]:"warn",[RULE_NAME$13]:"warn",[RULE_NAME$16]:"warn",[RULE_NAME$V]:"warn",[RULE_NAME$E]:"warn",[RULE_NAME$D]:"warn",[RULE_NAME$p]:"warn",[RULE_NAME$l]:"warn",[RULE_NAME$T]:"warn",[RULE_NAME$5]:"warn",[RULE_NAME$4]:"warn",[RULE_NAME$S]:"off",[RULE_NAME$R]:"warn",[RULE_NAME$3]:"off",[RULE_NAME$2]:"warn",[RULE_NAME$1]:"warn",[RULE_NAME$12]:"warn"},be={[RULE_NAME$13]:"error",[RULE_NAME$16]:"error",[RULE_NAME$V]:"error",[RULE_NAME$E]:"error",[RULE_NAME$D]:"error",[RULE_NAME$p]:"error",[RULE_NAME$l]:"error",[RULE_NAME$T]:"error"},Wr={[RULE_NAME$18]:ge,[RULE_NAME$17]:ke,[RULE_NAME$16]:xe,[RULE_NAME$15]:Ce,[RULE_NAME$14]:ve,[RULE_NAME$13]:Be,[RULE_NAME$12]:ye,[RULE_NAME$11]:Ie,[RULE_NAME$10]:Se,[RULE_NAME$$]:Oe,[RULE_NAME$_]:De,[RULE_NAME$Z]:He,[RULE_NAME$Y]:qe,[RULE_NAME$X]:Fe,[RULE_NAME$W]:Ve,[RULE_NAME$V]:Pe,[RULE_NAME$U]:Ge,[RULE_NAME$Q]:We,[RULE_NAME$P]:ze,[RULE_NAME$O]:Je,[RULE_NAME$N]:Qe,[RULE_NAME$M]:Xe,[RULE_NAME$L]:Ye,[RULE_NAME$K]:Ze,[RULE_NAME$J]:er,[RULE_NAME$I]:rr,[RULE_NAME$H]:or,[RULE_NAME$G]:ar,[RULE_NAME$T]:je,[RULE_NAME$F]:tr,[RULE_NAME$E]:sr,[RULE_NAME$D]:nr,[RULE_NAME$A]:pr,[RULE_NAME$C]:ir,[RULE_NAME$B]:mr,[RULE_NAME$z]:Er,[RULE_NAME$y]:fr,[RULE_NAME$x]:lr,[RULE_NAME$w]:Nr,[RULE_NAME$v]:cr,[RULE_NAME$u]:dr,[RULE_NAME$t]:Ar,[RULE_NAME$l]:_r,[RULE_NAME$s]:Mr,[RULE_NAME$r]:wr,[RULE_NAME$q]:Rr,[RULE_NAME$p]:Lr,[RULE_NAME$o]:ur,[RULE_NAME$n]:Tr,[RULE_NAME$m]:Ur,[RULE_NAME$k]:br,[RULE_NAME$j]:hr,[RULE_NAME$i]:gr,[RULE_NAME$h]:kr,[RULE_NAME$g]:xr,[RULE_NAME$f]:Cr,[RULE_NAME$e]:vr,[RULE_NAME$d]:Br,[RULE_NAME$7]:yr,[RULE_NAME$c]:Ir,[RULE_NAME$b]:Sr,[RULE_NAME$a]:Or,[RULE_NAME$9]:Dr,[RULE_NAME$8]:Hr,[RULE_NAME$6]:qr,[RULE_NAME$5]:Fr,[RULE_NAME$4]:Vr,[RULE_NAME$S]:Ke,[RULE_NAME$R]:$e,[RULE_NAME$3]:Pr,[RULE_NAME$2]:Gr,[RULE_NAME$1]:jr,[RULE_NAME]:Kr},f={meta:{name:"vitest",version},rules:Wr,environments:{env:{globals:{suite:!0,test:!0,describe:!0,it:!0,expectTypeOf:!0,assertType:!0,expect:!0,assert:!0,chai:!0,vitest:!0,vi:!0,beforeAll:!0,afterAll:!0,beforeEach:!0,afterEach:!0,onTestFailed:!0,onTestFinished:!0}}},configs:{"legacy-recommended":Ue(be),"legacy-all":Ue(_e),recommended:{name:"vitest/recommended",plugins:{get vitest(){return f}},rules:Te(be)},all:{name:"vitest/all",plugins:{get vitest(){return f}},rules:Te(_e)},env:{name:"vitest/env",languageOptions:{globals:{suite:"writable",test:"writable",describe:"writable",it:"writable",expectTypeOf:"writable",assertType:"writable",expect:"writable",assert:"writable",chai:"writable",vitest:"writable",vi:"writable",beforeAll:"writable",afterAll:"writable",beforeEach:"writable",afterEach:"writable",onTestFailed:"writable",onTestFinished:"writable"}}}}};module.exports=f;
